<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=480">

    <link rel="stylesheet" type="text/css" media="screen" href="/capnproto/stylesheets/stylesheet.css">

    <title>Cap'n Proto: The capnp Tool</title>

    <script type="text/javascript" src="/capnproto/javascripts/main.js"></script>
  </head>

  <body class="desktop">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <img src="/capnproto/images/logo.png">
        <div id="infinitely_faster">
          <img src="/capnproto/images/infinitely_faster.png">
        </div>
      </header>
      <a id="discuss_banner" href="https://groups.google.com/group/capnproto">Discuss on Groups</a>
      <a id="forkme_banner" href="https://github.com/kentonv/capnproto">View on GitHub</a>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">

      <section id="menu">
        <ul>
          <li><a href="/capnproto/index.html">Introduction</a></li>
          <li><a href="/capnproto/news/">News</a></li>
          <li><a href="/capnproto/install.html">Installation</a></li>
          <li><a href="/capnproto/language.html">Schema Language</a></li>
          <li><a href="/capnproto/encoding.html">Encoding</a></li>
          <li><a href="/capnproto/rpc.html">RPC Protocol</a></li>
          <li><a href="/capnproto/capnp-tool.html">The <code>capnp</code> Tool</a></li>
          <li><a href="/capnproto/cxx.html">C++ Runtime</a></li>
          <li><a href="/capnproto/otherlang.html">Other Languages</a></li>
          <li><a href="/capnproto/roadmap.html">Road Map</a></li>
        </ul>
      </section>
      <section id="main_content" class="inner">

<h1 id='the__tool'>The <code>capnp</code> Tool</h1>

<p>Cap&#8217;n Proto comes with a command-line tool called <code>capnp</code> intended to aid development and debugging. This tool can be used to:</p>

<ul>
<li>Compile Cap&#8217;n Proto schemas to produce source code in multiple languages.</li>

<li>Generate unique type IDs.</li>

<li>Decode Cap&#8217;n Proto messages to human-readable text.</li>

<li>Encode text representations of Cap&#8217;n Proto messages to binary.</li>

<li>Evaluate and extract constants defined in Cap&#8217;n Proto schemas.</li>
</ul>

<p>This page summarizes the functionality. A complete reference on the command&#8217;s usage can be found by typing:</p>

<pre><code>capnp help</code></pre>

<h2 id='compiling_schemas'>Compiling Schemas</h2>

<pre><code>capnp compile -oc++ myschema.capnp</code></pre>

<p>This generates files <code>myschema.capnp.h</code> and <code>myschema.capnp.c++</code> which contain C++ source code corresponding to the types defined in <code>myschema.capnp</code>. Options exist to control output location and import paths.</p>

<p>The above example generates C++ code, but the tool is able to generate output in any language for which a plugin is available. Compiler plugins are just regular programs named <code>capnpc-language</code>. For example, the above command runs <code>capnpc-c++</code>. <a href='otherlang.html#how_to_write_compiler_plugins'>More on how to write compiler plugins</a>.</p>

<p>Note that some Cap&#8217;n Proto implementations (especially for interpreted languages) do not require generating source code.</p>

<h2 id='decoding_messages'>Decoding Messages</h2>

<pre><code>capnp decode myschema.capnp MyType &lt; message.bin &gt; message.txt</code></pre>

<p><code>capnp decode</code> reads a binary Cap&#8217;n Proto message from standard input and decodes it to a human-readable text format (specifically, the format used for specifying constants and default values in <a href='language.html'>the schema language</a>). By default it expects an unpacked message, but you can decode a <a href='encoding.html#packing'>packed</a> message with the <code>--packed</code> flag.</p>

<h2 id='encoding_messages'>Encoding Messages</h2>

<pre><code>capnp encode myschema.capnp MyType &lt; message.txt &gt; message.bin</code></pre>

<p><code>capnp encode</code> is the opposite of <code>capnp decode</code>: it takes a text-format message on stdin and encodes it to binary (possibly <a href='encoding.html#packing'>packed</a>, with the <code>--packed</code> flag).</p>

<p>This is mainly useful for debugging purposes, to build test data or to apply tweaks to data decoded with <code>capnp decode</code>. You should not rely on <code>capnp encode</code> for encoding data written and maintained in text format long-term &#8211; instead, use <code>capnp eval</code>, which is much more powerful.</p>

<h2 id='evaluating_constants'>Evaluating Constants</h2>

<pre><code>capnp eval myschema.capnp myConstant</code></pre>

<p>This prints the value of <code>myConstant</code>, a <a href='language.html#constants'>const</a> declaration, after applying variable substitution. It can also output the value in binary format (<code>--binary</code> or <code>--packed</code>).</p>

<p>At first glance, this may seem no more interesting that <code>capnp encode</code>: the syntax used to define constants in schema files is the same as the format accepted by <code>capnp encode</code>, right? There is, however, a big difference: constants in schema files may be defined in terms of other constants, which may even be imported from other files.</p>

<p>As a result, <code>capnp eval</code> is a great basis for implementing config files. For example, a large company might maintain a production server that serves dozens of clients and needs configuration information about each one. Rather than maintaining the config as one enormous file, it can be written as several separate files with a master file that imports the rest.</p>

<p>Such a configuration should be compiled to binary format using <code>capnp eval</code> before deployment, in order to verify that there are no errors and to make deployment easier and faster. While you could techincally ship the text configs to production and have the servers parse them directly (e.g. with <code>capnp::SchemaParser</code>), encoding before deployment is more efficient and robust.</p>
<script type="text/javascript">setupSidebar()</script>
        <div style="clear: both;"></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cap'n Proto maintained by <a href="https://github.com/kentonv">kentonv</a>
          <span class="gplus-followbutton"><span class="g-follow" data-annotation="bubble" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
          <a href="https://www.gittip.com/kentonv/"><img class="gittip15" src="/capnproto/images/gittip15.png" alt="Gittip"></a></p>
        <p>Design by <a href="http://www.starfruit-cafe.net/blog">sailorhg</a> âˆ™ Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    <!-- Google+ follow button. -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>

    <!-- Google Analytics. -->
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-39711112-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>
  </body>
</html>

