<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=480">

    <link rel="stylesheet" type="text/css" media="screen" href="http://kentonv.github.com/capnproto/stylesheets/stylesheet.css">

    <title>Cap'n Proto: Introduction</title>

    <script type="text/javascript" src="http://kentonv.github.com/capnproto/javascripts/main.js"></script>
  </head>

  <body class="desktop">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <img src="http://kentonv.github.com/capnproto/images/logo.png">
        <div id="infinitely_faster">
          <img src="http://kentonv.github.com/capnproto/images/infinitely_faster.png">
        </div>
      </header>
      <a id="discuss_banner" href="https://groups.google.com/group/capnproto">Discuss on Groups</a>
      <a id="forkme_banner" href="https://github.com/kentonv/capnproto">View on GitHub</a>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">

<div class="highlight"><pre><span class="c1"># Copyright (c) 2013, Kenton Varda &lt;temporal@gmail.com&gt;</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions and the following disclaimer.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="c1"># ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="c1"># DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="c1"># ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c1"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c1"># ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c1"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="nd">@0xb312981b2552a250</span>;
<span class="c1"># Recall that Cap&#39;n Proto RPC allows messages to contain references to remote objects that</span>
<span class="c1"># implement interfaces.  These references are called &quot;capabilities&quot;, because they both designate</span>
<span class="c1"># the remote object to use and confer permission to use it.</span>
<span class="c1">#</span>
<span class="c1"># Recall also that Cap&#39;n Proto RPC has the feature that when a method call itself returns a</span>
<span class="c1"># capability, the caller can begin calling methods on that capability _before the first call has</span>
<span class="c1"># returned_.  The caller essentially sends a message saying &quot;Hey server, as soon as you finish</span>
<span class="c1"># that previous call, do this with the result!&quot;.  Cap&#39;n Proto&#39;s RPC protocol makes this possible.</span>
<span class="c1"># As a result, it is more complicated than most.</span>
<span class="c1">#</span>
<span class="c1"># Cap&#39;n Proto RPC is based heavily on CapTP:</span>
<span class="c1">#     http://www.erights.org/elib/distrib/captp/index.html</span>
<span class="c1">#</span>
<span class="c1"># Cap&#39;n Proto RPC takes place between &quot;vats&quot;.  A vat hosts some set of capabilities and talks to</span>
<span class="c1"># other vats through direct bilateral connections.  Typically, there is a 1:1 correspondence</span>
<span class="c1"># between vats and processes (in the unix sense of the word), although this is not strictly always</span>
<span class="c1"># true (one process could run multiple vats, or a distributed vat might live across many processes).</span>
<span class="c1">#</span>
<span class="c1"># Cap&#39;n Proto does not distinguish between &quot;clients&quot; and &quot;servers&quot; -- this is up to the application.</span>
<span class="c1"># Either end of any connection can potentially hold capabilities pointing to the other end, and</span>
<span class="c1"># can call methods on those capabilities.  In the doc comments below, we user the words &quot;sender&quot;</span>
<span class="c1"># and &quot;receiver&quot;.  These refer to the sender and receiver of an instance of the struct or field</span>
<span class="c1"># being documented.  Sometimes we refer to a &quot;third-party&quot; which is neither the sender nor the</span>
<span class="c1"># receiver.</span>
<span class="c1">#</span>
<span class="c1"># It is generally up to the vat network implementation to securely verify that connections are made</span>
<span class="c1"># to the intended vat as well as to encrypt transmitted data for privacy and integrity.  See the</span>
<span class="c1"># `VatNetwork` example interface near the end of this file.</span>
<span class="c1">#</span>
<span class="c1"># Once a connection is formed, nothing interesting can happen until one side sends a Restore</span>
<span class="c1"># message to obtain a persistent capability.</span>
<span class="c1">#</span>
<span class="c1"># Unless otherwise specified, messages must be delivered to the receiving application in the same</span>
<span class="c1"># order in which they were initiated by the sending application, just like in E:</span>
<span class="c1">#     http://erights.org/elib/concurrency/partial-order.html</span>
<span class="c1">#</span>
<span class="c1"># Since the full protocol is complicated, we define multiple levels of support which an</span>
<span class="c1"># implementation may target.  For typical applications, level 1 support will be sufficient.</span>
<span class="c1"># Comments in this file indicate which level requires the corresponding feature to be</span>
<span class="c1"># implemented.</span>
<span class="c1">#</span>
<span class="c1"># * **Level 0:** The implementation does not support object references.  `Restore` is supported</span>
<span class="c1">#   only for looking up singleton objects which exist for the lifetime of the server, and only</span>
<span class="c1">#   these singleton objects can receive calls.  At this level, the implementation does not support</span>
<span class="c1">#   object-oriented protocols and is similar in complexity to JSON-RPC or Protobuf &quot;generic</span>
<span class="c1">#   services&quot;.  This level should be considered only a temporary stepping-stone toward level 1 as</span>
<span class="c1">#   the lack of object references drastically changes how protocols are designed.  Applications</span>
<span class="c1">#   _should not_ attempt to design their protocols around the limitations of level 0</span>
<span class="c1">#   implementations.</span>
<span class="c1">#</span>
<span class="c1"># * **Level 1:** The implementation supports simple bilateral interaction with object references</span>
<span class="c1">#   and promise pipelining, but interactions between three or more parties are supported only via</span>
<span class="c1">#   proxying of objects.  E.g. if Alice wants to send Bob a capability pointing to Carol, Alice</span>
<span class="c1">#   must host a local proxy of Carol and send Bob a reference to that; Bob cannot form a direct</span>
<span class="c1">#   connection to Carol.  Level 1 implementations do not support &quot;join&quot; or &quot;eq&quot; across capabilities</span>
<span class="c1">#   received from different vats, although they should be supported on capabilities received from</span>
<span class="c1">#   the same vat.  `Restore` is supported only for looking up singleton objects as in level 0.</span>
<span class="c1">#</span>
<span class="c1"># * **Level 2:** The implementation supports saving, restoring, and deleting persistent</span>
<span class="c1">#   capabilities.</span>
<span class="c1">#</span>
<span class="c1"># * **Level 3:** The implementation supports three-way interactions but does not implement &quot;Join&quot;</span>
<span class="c1">#   operations.  The implementation can be used effectively on networks that do not require joins,</span>
<span class="c1">#   or to implement objects that never need to be joined.</span>
<span class="c1">#</span>
<span class="c1"># * **Level 4:** The entire protocol is implemented, including joins.</span>
<span class="c1">#</span>
<span class="c1"># Note that an implementation must also support specific networks (transports), as described in</span>
<span class="c1"># the &quot;Network-specific Parameters&quot; section below.  An implementation might have different levels</span>
<span class="c1"># depending on the network used.</span>
<span class="c1">#</span>
<span class="c1"># New implementations of Cap&#39;n Proto should start out targeting the simplistic &quot;confined&quot; network</span>
<span class="c1"># type as defined in `rpc-confined.capnp`.  With this network type, level 3 is irrelevant and</span>
<span class="c1"># levels 2 and 4 are much easier than usual to implement.  When such an implementation is actually</span>
<span class="c1"># run inside a container, the contained app effectively gets to make full use of the container&#39;s</span>
<span class="c1"># network at level 4.  And since Cap&#39;n Proto IPC is extremely fast, it may never make sense to</span>
<span class="c1"># bother implementing any other vat network protocol -- just use the correct container type and get</span>
<span class="c1"># it for free.</span>

<span class="k">using</span> <span class="n">Cxx</span> <span class="l">= import &quot;c++.capnp&quot;</span>;
<span class="na">$Cxx.namespace(&quot;capnp::rpc&quot;)</span>;

<span class="c1"># ========================================================================================</span>
<span class="c1"># The Four Tables</span>
<span class="c1">#</span>
<span class="c1"># Cap&#39;n Proto RPC connections are stateful (although an application built on Cap&#39;n Proto could</span>
<span class="c1"># export a stateless interface).  As in CapTP, for each open connection, a vat maintains four state</span>
<span class="c1"># tables: questions, answers, imports, and exports.  See the diagram at:</span>
<span class="c1">#     http://www.erights.org/elib/distrib/captp/4tables.html</span>
<span class="c1">#</span>
<span class="c1"># The question table corresponds to the other end&#39;s answer table, and the imports table corresponds</span>
<span class="c1"># to the other end&#39;s exports table.</span>
<span class="c1">#</span>
<span class="c1"># The entries in each table are identified by ID numbers (defined below as 32-bit integers).  These</span>
<span class="c1"># numbers are always specific to the connection; a newly-established connection starts with no</span>
<span class="c1"># valid IDs.  Since low-numbered IDs will pack better, it is suggested that IDs be assigned like</span>
<span class="c1"># Unix file descriptors -- prefer the lowest-number ID that is currently available.</span>
<span class="c1">#</span>
<span class="c1"># IDs in the questions/answers tables are chosen by the questioner and generally represent method</span>
<span class="c1"># calls that are in progress.</span>
<span class="c1">#</span>
<span class="c1"># IDs in the imports/exports tables are chosen by the exporter and generally represent objects on</span>
<span class="c1"># which methods may be called.  Exports may be &quot;settled&quot;, meaning the exported object is an actual</span>
<span class="c1"># object living in the exporter&#39;s vat, or they may be &quot;promises&quot;, meaning the exported object is</span>
<span class="c1"># the as-yet-unknown result of an ongoing operation and will eventually be resolved to some other</span>
<span class="c1"># object once that operation completes.  Calls made to a promise will be forwarded to the eventual</span>
<span class="c1"># target once it is known.  The eventual replacement object does *not* take the same ID as the</span>
<span class="c1"># promise, as it may turn out to be an object that is already exported (so already has an ID) or</span>
<span class="c1"># may even live in a completely different vat (and so won&#39;t get an ID on the same export table</span>
<span class="c1"># at all).</span>
<span class="c1">#</span>
<span class="c1"># IDs can be reused over time.  To make this safe, we carefully define the lifetime of IDs.  Since</span>
<span class="c1"># messages using the ID could be traveling in both directions simultaneously, we must define the</span>
<span class="c1"># end of life of each ID _in each direction_.  The ID is only safe to reuse once it has been</span>
<span class="c1"># released by both sides.</span>
<span class="c1">#</span>
<span class="c1"># When a Cap&#39;n Proto connection is lost, everything on the four tables is lost.  All questions are</span>
<span class="c1"># canceled and throw exceptions.  All imports become broken (all methods throw exceptions).  All</span>
<span class="c1"># exports and answers are implicitly released.  The only things not lost are persistent</span>
<span class="c1"># capabilities (`SturdyRef`s).  The application must plan for this and should respond by</span>
<span class="c1"># establishing a new connection and restoring from these persistent capabilities.</span>

<span class="k">using</span> <span class="n">QuestionId</span> <span class="l">= UInt32</span>;
<span class="c1"># **(level 0)**</span>
<span class="c1">#</span>
<span class="c1"># Identifies a question in the questions/answers table.  The questioner (caller) chooses an ID</span>
<span class="c1"># when making a call.  The ID remains valid in caller -&gt; callee messages until a Finish</span>
<span class="c1"># message is sent, and remains valid in callee -&gt; caller messages until a Return message is sent.</span>

<span class="k">using</span> <span class="n">ExportId</span> <span class="l">= UInt32</span>;
<span class="c1"># **(level 1)**</span>
<span class="c1">#</span>
<span class="c1"># Identifies an exported capability or promise in the exports/imports table.  The exporter chooses</span>
<span class="c1"># an ID before sending a capability over the wire.  If the capability is already in the table, the</span>
<span class="c1"># exporter should reuse the same ID.  If the ID is a promise (as opposed to a settled capability),</span>
<span class="c1"># this must be indicated at the time the ID is introduced; in this case, the importer shall expect</span>
<span class="c1"># a later Resolve message which replaces the promise.</span>
<span class="c1">#</span>
<span class="c1"># ExportIds are subject to reference counting.  When an `ExportId` is received embedded in an</span>
<span class="c1"># question or answer, the export has an implicit reference until that question or answer is</span>
<span class="c1"># released (questions are released by `Return`, answers are released by `Finish`).  Such an</span>
<span class="c1"># export can be retained beyond that point by including it in the `retainedCaps` list at the time</span>
<span class="c1"># the question/answer is released, thus incrementing its reference count.  The reference count is</span>
<span class="c1"># later decremented by a `Release` message.  Since the `Release` message can specify an arbitrary</span>
<span class="c1"># number by which to reduce the reference count, the importer should usually batch reference</span>
<span class="c1"># decrements and only send a `Release` when it believes the reference count has hit zero.  Of</span>
<span class="c1"># course, it is possible that a new reference to the released object is in-flight at the time</span>
<span class="c1"># that the `Release` message is sent, so it is necessary for the exporter to keep track of the</span>
<span class="c1"># reference count on its end as well to avoid race conditions.</span>
<span class="c1">#</span>
<span class="c1"># When an `ExportId` is received as part of a exporter -&gt; importer message but not embedded in a</span>
<span class="c1"># question or answer, its reference count must be incremented unless otherwise specified.</span>
<span class="c1">#</span>
<span class="c1"># An `ExportId` remains valid in importer -&gt; exporter messages until its reference count reaches</span>
<span class="c1"># zero and a `Release` message has been sent to release it.</span>
<span class="c1">#</span>
<span class="c1"># When a connection is lost, all exports are implicitly released.  It is not possible to restore</span>
<span class="c1"># a connection state (or, restoration should be implemented at the transport layer without the RPC</span>
<span class="c1"># layer knowing that anything happened).</span>

<span class="c1"># ========================================================================================</span>
<span class="c1"># Messages</span>

<span class="k">struct</span> <span class="n">Message</span> {
  <span class="c1"># An RPC connection is a bi-directional stream of Messages.</span>

  <span class="k">union</span> {
    <span class="n">unimplemented</span> <span class="nd">@0</span> <span class="nc">:Message</span>;
    <span class="c1"># When a peer receives a message of a type it doesn&#39;t recognize or doesn&#39;t support, it</span>
    <span class="c1"># must immediately echo the message back to the sender in `unimplemented`.  The sender is</span>
    <span class="c1"># then able to examine the message and decide how to deal with it being unimplemented.</span>
    <span class="c1">#</span>
    <span class="c1"># For example, say `resolve` is received by a level 0 implementation (because a previous call</span>
    <span class="c1"># or return happened to contain a promise).  The receiver will echo it back as `unimplemented`.</span>
    <span class="c1"># The sender can then simply release the cap to which the promise had resolved, thus avoiding</span>
    <span class="c1"># a leak.</span>
    <span class="c1">#</span>
    <span class="c1"># For any message type that introduces a question, if the message comes back unimplemented,</span>
    <span class="c1"># the sender may simply treat it as if the question failed with an exception.</span>
    <span class="c1">#</span>
    <span class="c1"># In cases where there is no sensible way to react to an `unimplemented` message (without</span>
    <span class="c1"># resource leaks or other serious problems), the connection may need to be aborted.  This is</span>
    <span class="c1"># a gray area; different implementations may take different approaches.</span>

    <span class="n">abort</span> <span class="nd">@1</span> <span class="nc">:Exception</span>;
    <span class="c1"># Sent when a connection is being aborted due to an unrecoverable error.  This could be e.g.</span>
    <span class="c1"># because the sender received an invalid or nonsensical message (`isCallersFault` is true) or</span>
    <span class="c1"># because the sender had an internal error (`isCallersFault` is false).  The sender will shut</span>
    <span class="c1"># down the outgoing half of the connection after `abort` and will completely close the</span>
    <span class="c1"># connection shortly thereafter (it&#39;s up to the sender how much of a time buffer they want to</span>
    <span class="c1"># offer for the client to receive the `abort` before the connection is reset).</span>

    <span class="c1"># Level 0 features -----------------------------------------------</span>

    <span class="n">call</span> <span class="nd">@2</span> <span class="nc">:Call</span>;         <span class="c1"># Begin a method call.</span>
    <span class="n">return</span> <span class="nd">@3</span> <span class="nc">:Return</span>;     <span class="c1"># Complete a method call.</span>
    <span class="n">finish</span> <span class="nd">@4</span> <span class="nc">:Finish</span>;     <span class="c1"># Release a returned answer / cancel a call.</span>

    <span class="c1"># Level 1 features -----------------------------------------------</span>

    <span class="n">resolve</span> <span class="nd">@5</span> <span class="nc">:Resolve</span>;   <span class="c1"># Resolve a previously-sent promise.</span>
    <span class="n">release</span> <span class="nd">@6</span> <span class="nc">:Release</span>;   <span class="c1"># Release a capability so that the remote object can be deallocated.</span>

    <span class="c1"># Level 2 features -----------------------------------------------</span>

    <span class="n">save</span> <span class="nd">@7</span> <span class="nc">:Save</span>;         <span class="c1"># Save a capability persistently.</span>
    <span class="n">restore</span> <span class="nd">@8</span> <span class="nc">:Restore</span>;   <span class="c1"># Restore a persistent capability from a previous connection.</span>
    <span class="n">delete</span> <span class="nd">@9</span> <span class="nc">:Delete</span>;     <span class="c1"># Delete a persistent capability.</span>

    <span class="c1"># Level 3 features -----------------------------------------------</span>

    <span class="n">provide</span> <span class="nd">@10</span> <span class="nc">:Provide</span>;  <span class="c1"># Provide a capability to a third party.</span>
    <span class="n">accept</span> <span class="nd">@11</span> <span class="nc">:Accept</span>;    <span class="c1"># Accept a capability provided by a third party.</span>

    <span class="c1"># Level 4 features -----------------------------------------------</span>

    <span class="n">join</span> <span class="nd">@12</span> <span class="nc">:Join</span>;        <span class="c1"># Directly connect to the common root of two or more proxied caps.</span>
  }
}

<span class="c1"># Level 0 message types ----------------------------------------------</span>

<span class="k">struct</span> <span class="n">Call</span> {
  <span class="c1"># **(level 0)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type initiating a method call on a capability.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># A number, chosen by the caller, which identifies this call in future messages.  This number</span>
  <span class="c1"># must be different from all other calls originating from the same end of the connection (but</span>
  <span class="c1"># may overlap with question IDs originating from the opposite end).  A fine strategy is to use</span>
  <span class="c1"># sequential question IDs, but the recipient should not assume this.</span>
  <span class="c1">#</span>
  <span class="c1"># A question ID can be reused once both:</span>
  <span class="c1"># - A matching Return has been received from the callee.</span>
  <span class="c1"># - A matching Finish has been sent from the caller.</span>

  <span class="n">target</span> <span class="nc">:union </span>{
    <span class="n">exportedCap</span> <span class="nd">@1</span> <span class="nc">:ExportId</span>;
    <span class="c1"># This call is to a capability or promise previously exported by the receiver.</span>

    <span class="n">promisedAnswer</span> <span class="nd">@2</span> <span class="nc">:PromisedAnswer</span>;
    <span class="c1"># This call is to a capability that is expected to be returned by another call that has not</span>
    <span class="c1"># yet been completed.</span>
    <span class="c1">#</span>
    <span class="c1"># At level 0, this is supported only for addressing the result of a previous `Restore`, so that</span>
    <span class="c1"># initial startup doesn&#39;t require a round trip.</span>
  }

  <span class="n">interfaceId</span> <span class="nd">@3</span> <span class="nc">:UInt64</span>;
  <span class="c1"># The type ID of the interface being called.  Each capability may implement multiple interfaces.</span>

  <span class="n">methodId</span> <span class="nd">@4</span> <span class="nc">:UInt16</span>;
  <span class="c1"># The ordinal number of the method to call within the requested interface.</span>

  <span class="n">request</span> <span class="nd">@5</span> <span class="nc">:Object</span>;
  <span class="c1"># The request struct.  The fields of this struct correspond to the parameters of the method.</span>
  <span class="c1">#</span>
  <span class="c1"># The request may contain capabilities.  These capabilities are automatically released when the</span>
  <span class="c1"># call returns *unless* the Return message explicitly indicates that they are being retained.</span>
}

<span class="k">struct</span> <span class="n">Return</span> {
  <span class="c1"># **(level 0)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent from callee to caller indicating that the call has completed.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># Question ID which is being answered, as specified in the corresponding Call.</span>

  <span class="n">retainedCaps</span> <span class="nd">@1</span> <span class="nc">:List(ExportId)</span>;
  <span class="c1"># **(level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># List of capabilities from the request to which the callee continues to hold references.  Any</span>
  <span class="c1"># other capabilities from the request are implicitly released.</span>

  <span class="k">union</span> {
    <span class="n">answer</span> <span class="nd">@2</span> <span class="nc">:Object</span>;
    <span class="c1"># Result object.  If the method returns a struct, this is it.  Otherwise, this points to</span>
    <span class="c1"># a struct which contains exactly one field, corresponding to the method&#39;s return type.</span>
    <span class="c1"># (This implies that an method&#39;s return type can be upgraded from a non-struct to a struct</span>
    <span class="c1"># without breaking wire compatibility.)</span>
    <span class="c1">#</span>
    <span class="c1"># For a `Return` in response to an `Accept`, `answer` is a capability pointer (and therefore</span>
    <span class="c1"># points to a `CapDescriptor`, but is tagged as a capability rather than a struct).  A</span>
    <span class="c1"># `Finish` is still required in this case, and the capability must still be listed in</span>
    <span class="c1"># `retainedCaps` if it is to be retained.</span>

    <span class="n">exception</span> <span class="nd">@3</span> <span class="nc">:Exception</span>;
    <span class="c1"># Indicates that the call failed and explains why.</span>

    <span class="n">canceled</span> <span class="nd">@4</span> <span class="nc">:Void</span>;
    <span class="c1"># Indicates that the call was canceled due to the caller sending a Finish message</span>
    <span class="c1"># before the call had completed.</span>

    <span class="n">unsupportedPipelineOp</span> <span class="nd">@5</span> <span class="nc">:Void</span>;
    <span class="c1"># The call was addressed to a `PromisedAnswer` that was not understood by the callee because</span>
    <span class="c1"># it used features that the callee&#39;s RPC implementation does not support.  The caller should</span>
    <span class="c1"># wait for the first call to return and then retry the dependent call as a regular,</span>
    <span class="c1"># non-pipelined call.</span>
  }
}

<span class="k">struct</span> <span class="n">Finish</span> {
  <span class="c1"># **(level 0)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent from the caller to the callee to indicate:</span>
  <span class="c1"># 1) The questionId will no longer be used in any messages sent by the callee (no further</span>
  <span class="c1">#    pipelined requests).</span>
  <span class="c1"># 2) Any capabilities in the answer other than the ones listed below should be implicitly</span>
  <span class="c1">#    released.</span>
  <span class="c1"># 3) If the answer has not returned yet, the caller no longer cares about the answer, so the</span>
  <span class="c1">#    callee may wish to immediately cancel the operation and send back a Return message with</span>
  <span class="c1">#    &quot;canceled&quot; set.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># ID of the question whose answer is to be released.</span>

  <span class="n">retainedCaps</span> <span class="nd">@1</span> <span class="nc">:List(ExportId)</span>;
  <span class="c1"># **(level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># List of capabilities from the answer to which the callee continues to hold references.  Any</span>
  <span class="c1"># other capabilities from the answer that need to be released are implicitly released along</span>
  <span class="c1"># with the answer itself.</span>
}

<span class="c1"># Level 1 message types ----------------------------------------------</span>

<span class="k">struct</span> <span class="n">Resolve</span> {
  <span class="c1"># **(level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to indicate that a previously-sent promise has now been resolved to some other</span>
  <span class="c1"># object (possibly another promise) -- or broken, or canceled.</span>
  <span class="c1">#</span>
  <span class="c1"># Keep in mind that it&#39;s possible for a `Resolve` to be sent to a level 0 implementation that</span>
  <span class="c1"># doesn&#39;t implement it.  For example, a method call or return might contain a capability in the</span>
  <span class="c1"># payload.  Normally this is fine even if the receiver is level 0, because they will implicitly</span>
  <span class="c1"># release all such capabilities on return / finish.  But if the cap happens to be a promise, then</span>
  <span class="c1"># a follow-up `Resolve` will be sent regardless of this release.  The level 0 receiver will reply</span>
  <span class="c1"># with an `unimplemented` message.  The sender (of the `Resolve`) can respond to this as if the</span>
  <span class="c1"># receiver had immediately released any capability to which the promise resolved.</span>

  <span class="n">promiseId</span> <span class="nd">@0</span> <span class="nc">:ExportId</span>;
  <span class="c1"># The ID of the promise to be resolved.</span>
  <span class="c1">#</span>
  <span class="c1"># Unlike all other instances of `ExportId` sent from the exporter, the `Resolve` message does</span>
  <span class="c1"># _not_ increase the reference count of `promiseId`.</span>
  <span class="c1">#</span>
  <span class="c1"># When a promise ID is first sent over the wire (e.g. in a `CapDescriptor`), the sender (exporter)</span>
  <span class="c1"># guarantees that it will follow up at some point with exactly one `Resolve` message.  If the</span>
  <span class="c1"># same `promiseId` is sent again before `Resolve`, still only one `Resolve` is sent.  If the</span>
  <span class="c1"># same ID is reused again later _after_ a `Resolve`, it can only be because the export&#39;s</span>
  <span class="c1"># reference count hit zero in the meantime and the ID was re-assigned to a new export, therefore</span>
  <span class="c1"># this later promise does _not_ correspond to the earlier `Resolve`.</span>
  <span class="c1">#</span>
  <span class="c1"># If a promise ID&#39;s reference count reaches zero before a `Resolve` is sent, the `Resolve`</span>
  <span class="c1"># message must still be sent, and the ID cannot be reused in the meantime.  Moreover, the object</span>
  <span class="c1"># to which the promise resolved itself needs to be released, even if the promise was already</span>
  <span class="c1"># released before it resolved.  (Although, the exporter may notice that the promise was released</span>
  <span class="c1"># and send a `canceled` resolution, in which case nothing new is exported.)</span>
  <span class="c1">#</span>
  <span class="c1"># RPC implementations should keep in mind when they receive a `Resolve` that the promise ID may</span>
  <span class="c1"># have appeared in a previous question or answer which the application has not consumed yet.</span>
  <span class="c1"># The RPC implementation usually shouldn&#39;t dig through the question/answer itself looking for</span>
  <span class="c1"># capabilities, so it won&#39;t be aware of any promise IDs in that message until the application</span>
  <span class="c1"># actually goes through and extracts the capabilities it wishes to retain.  Therefore, when</span>
  <span class="c1"># a `Resolve` is received, the RPC implementation will have to keep track of this resolution</span>
  <span class="c1"># at least until all previously-received questions and answers have been consumed and released</span>
  <span class="c1"># by the application.</span>

  <span class="k">union</span> {
    <span class="n">cap</span> <span class="nd">@1</span> <span class="nc">:CapDescriptor</span>;
    <span class="c1"># The object to which the promise resolved.</span>

    <span class="n">exception</span> <span class="nd">@2</span> <span class="nc">:Exception</span>;
    <span class="c1"># Indicates that the promise was broken.</span>

    <span class="n">canceled</span> <span class="nd">@3</span> <span class="nc">:Void</span>;
    <span class="c1"># Indicates that this promise won&#39;t be resolved because its reference count reached zero before</span>
    <span class="c1"># it had completed, so the operation was canceled.</span>
  }
}

<span class="k">struct</span> <span class="n">Release</span> {
  <span class="c1"># **(level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to indicate that the sender is done with the given capability and the receiver</span>
  <span class="c1"># can free resources allocated to it.</span>

  <span class="n">id</span> <span class="nd">@0</span> <span class="nc">:ExportId</span>;
  <span class="c1"># What to release.</span>

  <span class="n">referenceCount</span> <span class="nd">@1</span> <span class="nc">:UInt32</span>;
  <span class="c1"># The amount by which to decrement the reference count.  The export is only actually released</span>
  <span class="c1"># when the reference count reaches zero.</span>
}

<span class="c1"># Level 2 message types ----------------------------------------------</span>

<span class="k">struct</span> <span class="n">Save</span> {
  <span class="c1"># **(level 2)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to save a capability persistently so that it can be restored by a future</span>
  <span class="c1"># connection.  Not all capabilities can be saved -- application interfaces should define which</span>
  <span class="c1"># capabilities support this and which do not.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># A new question ID identifying this request, which will eventually receive a Return</span>
  <span class="c1"># message whose `answer` is a SturdyRef.</span>

  <span class="n">target</span> <span class="nc">:union </span>{
    <span class="c1"># What is to be saved.</span>

    <span class="n">exportedCap</span> <span class="nd">@1</span> <span class="nc">:ExportId</span>;
    <span class="c1"># An exported capability.</span>

    <span class="n">promisedAnswer</span> <span class="nd">@2</span> <span class="nc">:PromisedAnswer</span>;
    <span class="c1"># A capability expected to be returned in the answer to an outstanding question.</span>
  }
}

<span class="k">struct</span> <span class="n">Restore</span> {
  <span class="c1"># **(mostly level 2)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to restore a persistent capability obtained during a previous connection, or</span>
  <span class="c1"># through other means.</span>
  <span class="c1">#</span>
  <span class="c1"># Level 0/1 implementations need to implement a limited version of `Restore` only for the purpose</span>
  <span class="c1"># of bootstrapping a new connection (otherwise, there would be no objects to which to address</span>
  <span class="c1"># methods).  These levels may simply implement singleton services that exist for the lifetime of</span>
  <span class="c1"># the host process and probably have non-secret names.  A level 0 receiver of `Restore` should</span>
  <span class="c1"># never actually send a `Return` message, but should simply expect `Call` messages addressed to</span>
  <span class="c1"># the `PromisedAnswer` corresponding to the `Restore`.  A level 0 sender of `Restore` can ignore</span>
  <span class="c1"># the corresponding `Return` and just keep addressing the `PromisedAnswer`.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># A new question ID identifying this request, which will eventually receive a Return message</span>
  <span class="c1"># containing the restored capability.</span>

  <span class="n">ref</span> <span class="nd">@1</span> <span class="nc">:SturdyRef</span>;
  <span class="c1"># Designates the capability to restore.</span>
}

<span class="k">struct</span> <span class="n">Delete</span> {
  <span class="c1"># **(level 2)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to delete a previously-saved persistent capability.  In other words, this</span>
  <span class="c1"># means &quot;this ref will no longer be used in the future&quot;, so that the host can potentially</span>
  <span class="c1"># garbage collect resources associated with it.  Note that if any ExportId still refers to a</span>
  <span class="c1"># capability restored from this ref, that export should still remain valid until released.</span>
  <span class="c1">#</span>
  <span class="c1"># Different applications may define different policies regarding saved capability lifetimes that</span>
  <span class="c1"># may or may not rely on `Delete`.  For the purpose of implementation freedom, a receiver is</span>
  <span class="c1"># allowed to silently ignore a delete request for a reference it doesn&#39;t recognize.  This way,</span>
  <span class="c1"># a persistent capability could be given an expiration time, after which the capability is</span>
  <span class="c1"># automatically deleted, and any future `Delete` message is ignored.</span>
  <span class="c1">#</span>
  <span class="c1"># A client must send no more than one `Delete` message for any given `Save`, so that a host</span>
  <span class="c1"># can potentially implement reference counting.  However, hosts should be wary of reference</span>
  <span class="c1"># counting across multiple clients, as a malicious client could of course send multiple</span>
  <span class="c1"># `Delete`s.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># A new question ID identifying this request, which will eventually receive a Return message</span>
  <span class="c1"># with an empty answer.</span>

  <span class="n">ref</span> <span class="nd">@1</span> <span class="nc">:SturdyRef</span>;
  <span class="c1"># Designates the capability to delete.</span>
}

<span class="c1"># Level 3 message types ----------------------------------------------</span>

<span class="k">struct</span> <span class="n">Provide</span> {
  <span class="c1"># **(level 3)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to indicate that the sender wishes to make a particular capability implemented</span>
  <span class="c1"># by the receiver available to a third party for direct access (without the need for the third</span>
  <span class="c1"># party to proxy through the sender).</span>
  <span class="c1">#</span>
  <span class="c1"># (In CapTP, `Provide` and `Accept` are methods of the global `NonceLocator` object exported by</span>
  <span class="c1"># every vat.  In Cap&#39;n Proto, we bake this into the core protocol.)</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># Question ID to be held open until the recipient has received the capability.  An answer will</span>
  <span class="c1"># be returned once the third party has successfully received the capability.  The sender must</span>
  <span class="c1"># at some point send a `Finish` message as with any other call, and such a message can be</span>
  <span class="c1"># used to cancel the whole operation.</span>

  <span class="n">target</span> <span class="nc">:union </span>{
    <span class="c1"># What is to be provided to the third party.</span>

    <span class="n">exportedCap</span> <span class="nd">@1</span> <span class="nc">:ExportId</span>;
    <span class="c1"># An exported capability.</span>

    <span class="n">promisedAnswer</span> <span class="nd">@2</span> <span class="nc">:PromisedAnswer</span>;
    <span class="c1"># A capability expected to be returned in the answer to an outstanding question.</span>
  }

  <span class="n">recipient</span> <span class="nd">@3</span> <span class="nc">:RecipientId</span>;
  <span class="c1"># Identity of the third party which is expected to pick up the capability.</span>
}

<span class="k">struct</span> <span class="n">Accept</span> {
  <span class="c1"># **(level 3)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to pick up a capability hosted by the receiving vat and provided by a third</span>
  <span class="c1"># party.  The third party previously designated the capability using `Provide`.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># A new question ID identifying this accept message, which will eventually receive a Return</span>
  <span class="c1"># message containing the provided capability.</span>

  <span class="n">provision</span> <span class="nd">@1</span> <span class="nc">:ProvisionId</span>;
  <span class="c1"># Identifies the provided object to be picked up.</span>
}

<span class="c1"># Level 4 message types ----------------------------------------------</span>

<span class="k">struct</span> <span class="n">Join</span> {
  <span class="c1"># **(level 4)**</span>
  <span class="c1">#</span>
  <span class="c1"># Message type sent to implement E.join(), which, given a number of capabilities which are</span>
  <span class="c1"># expected to be equivalent, finds the underlying object upon which they all agree and forms a</span>
  <span class="c1"># direct connection to it, skipping any proxies which may have been constructed by other vats</span>
  <span class="c1"># while transmitting the capability.  See:</span>
  <span class="c1">#     http://erights.org/elib/equality/index.html</span>
  <span class="c1">#</span>
  <span class="c1"># Note that this should only serve to bypass fully-transparent proxies -- proxies that were</span>
  <span class="c1"># created merely for convenience, without any intention of hiding the underlying object.</span>
  <span class="c1">#</span>
  <span class="c1"># For example, say Bob holds two capabilities hosted by Alice and Carol, but he expects that both</span>
  <span class="c1"># are simply proxies for a capability hosted elsewhere.  He then issues a join request, which</span>
  <span class="c1"># operates as follows:</span>
  <span class="c1"># - Bob issues Join requests on both Alice and Carol.  Each request contains a different piece</span>
  <span class="c1">#   of the JoinKey.</span>
  <span class="c1"># - Alice is proxying a capability hosted by Dana, so forwards the request to Dana&#39;s cap.</span>
  <span class="c1"># - Dana receives the first request and sees that the JoinKeyPart is one of two.  She notes that</span>
  <span class="c1">#   she doesn&#39;t have the other part yet, so she records the request and responds with a</span>
  <span class="c1">#   JoinAnswer.</span>
  <span class="c1"># - Alice relays the JoinAswer back to Bob.</span>
  <span class="c1"># - Carol is also proxying a capability from Dana, and so forwards her Join request to Dana as</span>
  <span class="c1">#   well.</span>
  <span class="c1"># - Dana receives Carol&#39;s request and notes that she now has both parts of a JoinKey.  She</span>
  <span class="c1">#   combines them in order to form information needed to form a secure connection to Bob.  She</span>
  <span class="c1">#   also responds with another JoinAnswer.</span>
  <span class="c1"># - Bob receives the responses from Alice and Carol.  He uses the returned JoinAnswers to</span>
  <span class="c1">#   determine how to connect to Dana and attempts to form the connection.  Since Bob and Dana now</span>
  <span class="c1">#   agree on a secret key which neither Alice nor Carol ever saw, this connection can be made</span>
  <span class="c1">#   securely even if Alice or Carol is conspiring against the other.  (If Alice and Carol are</span>
  <span class="c1">#   conspiring _together_, they can obviously reproduce the key, but this doesn&#39;t matter because</span>
  <span class="c1">#   the whole point of the join is to verify that Alice and Carol agree on what capability they</span>
  <span class="c1">#   are proxying.)</span>
  <span class="c1">#</span>
  <span class="c1"># If the two capabilities aren&#39;t actually proxies of the same object, then the join requests</span>
  <span class="c1"># will come back with conflicting `hostId`s and the join will fail before attempting to form any</span>
  <span class="c1"># connection.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># Question ID used to respond to this Join.  (Note that this ID only identifies one part of the</span>
  <span class="c1"># request for one hop; each part has a different ID and relayed copies of the request have</span>
  <span class="c1"># (probably) different IDs still.)</span>
  <span class="c1">#</span>
  <span class="c1"># The receiver will reply with a `Return` whose `answer` is a JoinAnswer.  This `JoinAnswer`</span>
  <span class="c1"># is relayed from the joined object&#39;s host, possibly with transformation applied as needed</span>
  <span class="c1"># by the network.</span>
  <span class="c1">#</span>
  <span class="c1"># Like any answer, the answer must be released using a `Finish`.  However, this release</span>
  <span class="c1"># should not occur until the joiner has either successfully connected to the joined object.</span>
  <span class="c1"># Vats relaying a `Join` message similarly must not release the answer they receive until the</span>
  <span class="c1"># answer they relayed back towards the joiner has itself been released.  This allows the</span>
  <span class="c1"># joined object&#39;s host to detect when the Join operation is canceled before completing -- if</span>
  <span class="c1"># it receives a `Finish` for one of the join answers before the joiner successfully</span>
  <span class="c1"># connects.  It can then free any resources it had allocated as part of the join.</span>

  <span class="n">capId</span> <span class="nd">@1</span> <span class="nc">:ExportId</span>;
  <span class="c1"># The capability to join.</span>

  <span class="n">keyPart</span> <span class="nd">@2</span> <span class="nc">:JoinKeyPart</span>;
  <span class="c1"># A part of the join key.  These combine to form the complete join key which is used to establish</span>
  <span class="c1"># a direct connection.</span>

  <span class="c1"># TODO(now):  Change this so that multiple parts can be sent in a single Join message, so that</span>
  <span class="c1"># if multiple join parts are going to cross the same connection they can be sent together, so that</span>
  <span class="c1"># the receive can potentially optimize its handling of them.  In the case where all parts are</span>
  <span class="c1"># bundled together, should the recipient be expected to simply return a cap, so that the caller</span>
  <span class="c1"># can immediately start pipelining to it?</span>
}

<span class="c1"># ========================================================================================</span>
<span class="c1"># Common structures used in messages</span>

<span class="k">struct</span> <span class="n">CapDescriptor</span> {
  <span class="c1"># **(level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># When an application-defined type contains an interface pointer, that pointer&#39;s encoding is the</span>
  <span class="c1"># same as a struct pointer except that the bottom two bits are 1&#39;s instead of 0&#39;s.  The pointer</span>
  <span class="c1"># actually points to an instance of `CapDescriptor`.  The runtime API should not reveal the</span>
  <span class="c1"># CapDescriptor directly to the application, but should instead wrap it in some kind of callable</span>
  <span class="c1"># object with methods corresponding to the interface that the capability implements.</span>
  <span class="c1">#</span>
  <span class="c1"># Keep in mind that `ExportIds` in a `CapDescriptor` are subject to reference counting.  See the</span>
  <span class="c1"># description of `ExportId`.</span>

  <span class="k">union</span> {
    <span class="n">senderHosted</span> <span class="nc">:group </span>{
      <span class="c1"># A capability newly exported by the sender.</span>

      <span class="n">id</span> <span class="nd">@0</span> <span class="nc">:ExportId</span>;
      <span class="c1"># The ID of the new capability in the sender&#39;s export table (receiver&#39;s import table).</span>

      <span class="n">interfaces</span> <span class="nd">@1</span> <span class="nc">:List(UInt64)</span>;
      <span class="c1"># Type IDs of interfaces supported by this descriptor.  This must include at least the</span>
      <span class="c1"># interface type as defined in the schema file, but could include others.  The runtime API</span>
      <span class="c1"># should allow the interface wrapper to be dynamically cast to these other types (probably</span>
      <span class="c1"># not using the language&#39;s built-in cast syntax, but something equivalent).</span>
    }

    <span class="n">senderPromise</span> <span class="nd">@2</span> <span class="nc">:ExportId</span>;
    <span class="c1"># A promise which the sender will resolve later.  The sender will send exactly one Resolve</span>
    <span class="c1"># message at a future point in time to replace this promise.</span>

    <span class="n">receiverHosted</span> <span class="nd">@3</span> <span class="nc">:ExportId</span>;
    <span class="c1"># A capability (or promise) previously exported by the receiver.</span>

    <span class="n">receiverAnswer</span> <span class="nd">@4</span> <span class="nc">:PromisedAnswer</span>;
    <span class="c1"># A capability expected to be returned in the answer for a currently-outstanding question posed</span>
    <span class="c1"># by the sender.</span>

    <span class="n">thirdPartyHosted</span> <span class="nd">@5</span> <span class="nc">:ThirdPartyCapDescriptor</span>;
    <span class="c1"># **(level 3)**</span>
    <span class="c1">#</span>
    <span class="c1"># A capability that lives in neither the sender&#39;s nor the receiver&#39;s vat.  The sender needs</span>
    <span class="c1"># to form a direct connection to a third party to pick up the capability.</span>
  }
}

<span class="k">struct</span> <span class="n">PromisedAnswer</span> {
  <span class="c1"># **(mostly level 1)**</span>
  <span class="c1">#</span>
  <span class="c1"># Specifies how to derive a promise from an unanswered question, by specifying the path of fields</span>
  <span class="c1"># to follow from the root of the eventual answer struct to get to the desired capability.  Used</span>
  <span class="c1"># to address method calls to a not-yet-returned capability or to pass such a capability as an</span>
  <span class="c1"># input to some other method call.</span>
  <span class="c1">#</span>
  <span class="c1"># Level 0 implementations must support `PromisedAnswer` only for the case where the answer is</span>
  <span class="c1"># to a `Restore` message.  In this case, `path` is always empty since `Restore` always returns</span>
  <span class="c1"># a raw capability.</span>

  <span class="n">questionId</span> <span class="nd">@0</span> <span class="nc">:QuestionId</span>;
  <span class="c1"># ID of the question (in the sender&#39;s question table / receiver&#39;s answer table) whose answer is</span>
  <span class="c1"># expected to contain the capability.</span>

  <span class="n">transform</span> <span class="nd">@1</span> <span class="nc">:List(Op)</span>;
  <span class="c1"># Operations / transformations to apply to the answer in order to get the capability actually</span>
  <span class="c1"># being addressed.  E.g. if the answer is a struct and you want to call a method on a capability</span>
  <span class="c1"># pointed to by a field of the struct, you need a `getPointerField` op.</span>

  <span class="k">struct</span> <span class="n">Op</span> {
    <span class="c1"># If an RPC implementation receives an `Op` of a type it doesn&#39;t recognize, it should</span>
    <span class="c1"># reply with a `Return` with `unsupportedPipelineOp` set.</span>

    <span class="k">union</span> {
      <span class="n">noop</span> <span class="nd">@0</span> <span class="nc">:Void</span>;
      <span class="c1"># Does nothing.  This member is mostly defined so that we can make `Op` a union even</span>
      <span class="c1"># though (as of this writing) only one real operation is defined.</span>

      <span class="n">getPointerField</span> <span class="nd">@1</span> <span class="nc">:UInt16</span>;
      <span class="c1"># Get a pointer field within a struct.  The number is an index into the pointer section, NOT</span>
      <span class="c1"># a field ordinal, so that the receiver does not need to understand the schema.</span>

      <span class="c1"># TODO(someday):  We could add:</span>
      <span class="c1"># - For lists, the ability to address every member of the list, or a slice of the list, the</span>
      <span class="c1">#   answer to which would be another list.  This is useful for implementing the equivalent of</span>
      <span class="c1">#   a SQL table join (not to be confused with the `Join` message type).</span>
      <span class="c1"># - Maybe some ability to test a union.</span>
      <span class="c1"># - Probably not a good idea:  the ability to specify an arbitrary script to run on the</span>
      <span class="c1">#   result.  We could define a little stack-based language where `PathPart` specifies one</span>
      <span class="c1">#   &quot;instruction&quot; or transformation to apply.  Although this is not a good idea</span>
      <span class="c1">#   (over-engineered), any narrower additions to `PathPart` should be designed as if this</span>
      <span class="c1">#   were the eventual goal.</span>
    }
  }
}

<span class="k">struct</span> <span class="n">ThirdPartyCapDescriptor</span> {
  <span class="c1"># **(level 3)**</span>
  <span class="c1">#</span>
  <span class="c1"># Identifies a capability in a third-party vat which the sender wants the receiver to pick up.</span>

  <span class="n">id</span> <span class="nd">@0</span> <span class="nc">:ThirdPartyCapId</span>;
  <span class="c1"># Identifies the third-party host and the specific capability to accept from it.</span>

  <span class="n">vineId</span> <span class="nd">@1</span> <span class="nc">:ExportId</span>;
  <span class="c1"># Object in the sender&#39;s export table which must be Released once the capability has been</span>
  <span class="c1"># successfully obtained from the third-party vat.  This allows the sender to ensure that the</span>
  <span class="c1"># final capability is not released before the receiver manages to accept it.  In CapTP</span>
  <span class="c1"># terminology this is called a &quot;vine&quot;, because it is an indirect reference to the third-party</span>
  <span class="c1"># object that snakes through the sender vat.  The vine does not accept any method calls.</span>
}

<span class="k">struct</span> <span class="n">Exception</span> {
  <span class="c1"># **(level 0)**</span>
  <span class="c1">#</span>
  <span class="c1"># Describes an arbitrary error that prevented an operation (e.g. a call) from completing.</span>

  <span class="n">reason</span> <span class="nd">@0</span> <span class="nc">:Text</span>;
  <span class="c1"># Human-readable failure description.</span>

  <span class="n">isCallersFault</span> <span class="nd">@1</span> <span class="nc">:Bool</span>;
  <span class="c1"># In the best estimate of the error source, is it the caller&#39;s fault that this error occurred</span>
  <span class="c1"># (like HTTP 400), or is it the callee&#39;s fault (like HTTP 500)?  Or, put another way, if an</span>
  <span class="c1"># automated bug report were to be generated for this error, should it be initially filed on the</span>
  <span class="c1"># caller&#39;s code or the callee&#39;s?  This is a guess.  Generally guesses should err towards blaming</span>
  <span class="c1"># the callee -- at the very least, the callee should be on the hook for improving their error</span>
  <span class="c1"># handling to be more confident.</span>

  <span class="n">isPermanent</span> <span class="nd">@2</span> <span class="nc">:Bool</span>;
  <span class="c1"># In the best estimate of the error source, is this error likely to repeat if the same call is</span>
  <span class="c1"># executed again?  Callers might use this to decide when to retry a request.</span>

  <span class="n">isOverloaded</span> <span class="nd">@3</span> <span class="nc">:Bool</span>;
  <span class="c1"># In the best estimate of the error source, is it likely this error was caused by the system</span>
  <span class="c1"># being overloaded?  If so, the caller probably should not retry the request now, but may</span>
  <span class="c1"># consider retrying it later.</span>
}

<span class="c1"># ========================================================================================</span>
<span class="c1"># Network-specific Parameters</span>
<span class="c1">#</span>
<span class="c1"># Some parts of the Cap&#39;n Proto RPC protocol are not specified here because different vat networks</span>
<span class="c1"># may wish to use different approaches to solving them.  For example, on the public internet, you</span>
<span class="c1"># may want to authenticate vats using public-key cryptography, but on a local intranet with trusted</span>
<span class="c1"># infrastructure, you may be happy to authenticate based on network address only, or some other</span>
<span class="c1"># lightweight mechanism.</span>
<span class="c1">#</span>
<span class="c1"># To accommodate this, we specify several &quot;parameter&quot; types.  Each type is defined here as an</span>
<span class="c1"># alias for `Object`, but a specific network will want to define a specific set of types to use.</span>
<span class="c1"># All vats in a vat network must agree on these parameters in order to be able to communicate.</span>
<span class="c1"># Inter-network communication can be accomplished through &quot;gateways&quot; that perform translation</span>
<span class="c1"># between the primitives used on each network; these gateways may need to be deeply stateful,</span>
<span class="c1"># depending on the translations they perform.</span>
<span class="c1">#</span>
<span class="c1"># For interaction over the global internet between parties with no other prior arrangement, a</span>
<span class="c1"># particular set of bindings for these types is defined elsewhere.  (TODO(soon): Specify where</span>
<span class="c1"># these common definitions live.)</span>
<span class="c1">#</span>
<span class="c1"># Another common network type is the &quot;confined&quot; network, in which a contained vat interacts with</span>
<span class="c1"># the outside world entirely through a container/supervisor.  All objects in the world that aren&#39;t</span>
<span class="c1"># hosted by the contained vat appear as if they were hosted by the container.  This network type is</span>
<span class="c1"># interesting because from the containee&#39;s point of view, there are no three-party interactions at</span>
<span class="c1"># all, and joins are unusually simple to implement, so implementing at level 4 is barely more</span>
<span class="c1"># complicated than implementing at level 1.  Moreover, if you pair an app implementing the confined</span>
<span class="c1"># network with a container that implements some other network, the app can then participate on</span>
<span class="c1"># the container&#39;s network just as if it implemented that network directly.  The types used by the</span>
<span class="c1"># &quot;confined&quot; network are defined in `rpc-confined.capnp`.</span>
<span class="c1">#</span>
<span class="c1"># The things which we need to parameterize are:</span>
<span class="c1"># - How to store capabilities long-term without holding a connection open (mostly level 2).</span>
<span class="c1"># - How to authenticate vats in three-party introductions (level 3).</span>
<span class="c1"># - How to implement `Join` (level 4).</span>
<span class="c1">#</span>
<span class="c1"># Persistent references</span>
<span class="c1"># ---------------------</span>
<span class="c1">#</span>
<span class="c1"># **(mostly level 2)**</span>
<span class="c1">#</span>
<span class="c1"># We want to allow some capabilities to be stored long-term, even if a connection is lost and later</span>
<span class="c1"># recreated.  ExportId is a short-term identifier that is specific to a connection, so it doesn&#39;t</span>
<span class="c1"># help here.  We need a way to specify long-term identifiers, as well as a strategy for</span>
<span class="c1"># reconnecting to a referenced capability later.</span>
<span class="c1">#</span>
<span class="c1"># Three-party interactions</span>
<span class="c1"># ------------------------</span>
<span class="c1">#</span>
<span class="c1"># **(level 3)**</span>
<span class="c1">#</span>
<span class="c1"># In cases where more than two vats are interacting, we have situations where VatA holds a</span>
<span class="c1"># capability hosted by VatB and wants to send that capability to VatC.  This can be accomplished</span>
<span class="c1"># by VatA proxying requests on the new capability, but doing so has two big problems:</span>
<span class="c1"># - It&#39;s inefficient, requiring an extra network hop.</span>
<span class="c1"># - If VatC receives another capability to the same object from VatD, it is difficult for VatC to</span>
<span class="c1">#   detect that the two capabilities are really the same and to implement the E &quot;join&quot; operation,</span>
<span class="c1">#   which is necessary for certain four-or-more-party interactions, such as the escrow pattern.</span>
<span class="c1">#   See:  http://www.erights.org/elib/equality/grant-matcher/index.html</span>
<span class="c1">#</span>
<span class="c1"># Instead, we want a way for VatC to form a direct, authenticated connection to VatB.</span>
<span class="c1">#</span>
<span class="c1"># Join</span>
<span class="c1"># ----</span>
<span class="c1">#</span>
<span class="c1"># **(level 4)**</span>
<span class="c1">#</span>
<span class="c1"># The `Join` message type and corresponding operation arranges for a direct connection to be formed</span>
<span class="c1"># between the joiner and the host of the joined object, and this connection must be authenticated.</span>
<span class="c1"># Thus, the details are network-dependent.</span>

<span class="k">using</span> <span class="n">SturdyRef</span> <span class="l">= Object</span>;
<span class="c1"># **(mostly level 2)**</span>
<span class="c1">#</span>
<span class="c1"># Identifies a long-lived capability which can be obtained again in a future connection by sending</span>
<span class="c1"># a `Restore` message.  A SturdyRef is a lot like a URL, but possibly with additional</span>
<span class="c1"># considerations e.g. to support authentication without a certificate authority.</span>
<span class="c1">#</span>
<span class="c1"># The base RPC protocol does not specify under what conditions a SturdyRef can</span>
<span class="c1"># be restored.  For example:</span>
<span class="c1"># - Do you have to connect to a specific vat to restore the reference?</span>
<span class="c1"># - Is just any vat allowed to restore the SturdyRef, or is it tied to a specific vat requiring</span>
<span class="c1">#   some form of authentication?</span>
<span class="c1">#</span>
<span class="c1"># At the very least, a SturdyRef must contain at least enough information to determine where to</span>
<span class="c1"># connect to restore the ref.  Ideally, this information is not a physical machine address, but a</span>
<span class="c1"># logical identifier that can be passed to some lookup service to locate an appropriate vat.  Using</span>
<span class="c1"># a physical machine address would make the network brittle -- a change in topology could</span>
<span class="c1"># invalidate all SturdyRefs.</span>
<span class="c1">#</span>
<span class="c1"># The ref should also contain some kind of signature or certificate which can be used to</span>
<span class="c1"># authenticate the vat, to protect against a malicious lookup service without the need for a</span>
<span class="c1"># centralized certificate authority.</span>
<span class="c1">#</span>
<span class="c1"># For example, a simple internet-friendly SturdyRef might contain a DNS host name, a public key</span>
<span class="c1"># fingerprint, and a Swiss number (large, unguessable random number;</span>
<span class="c1"># http://wiki.erights.org/wiki/Swiss_number) to identify the specific object within that vat.</span>
<span class="c1"># This construction does have the disadvantage, though, that a compromised private key could</span>
<span class="c1"># invalidate all existing refs that share that key, and a compromise of any one client&#39;s storage</span>
<span class="c1"># could require revoking all existing refs to that object.  Various more-sophisticated mechanisms</span>
<span class="c1"># can solve these problems but these are beyond the scope of this protocol.</span>

<span class="k">using</span> <span class="n">ProvisionId</span> <span class="l">= Object</span>;
<span class="c1"># **(level 3)**</span>
<span class="c1">#</span>
<span class="c1"># The information which must be sent in an `Accept` message to identify the object being accepted.</span>
<span class="c1">#</span>
<span class="c1"># In a network where each vat has a public/private key pair, this could simply be the public key</span>
<span class="c1"># fingerprint of the provider vat along with the questionId used in the `Provide` message sent from</span>
<span class="c1"># that provider.</span>

<span class="k">using</span> <span class="n">RecipientId</span> <span class="l">= Object</span>;
<span class="c1"># **(level 3)**</span>
<span class="c1">#</span>
<span class="c1"># The information which must be sent in a `Provide` message to identify the recipient of the</span>
<span class="c1"># capability.</span>
<span class="c1">#</span>
<span class="c1"># In a network where each vat has a public/private key pair, this could simply be the public key</span>
<span class="c1"># fingerprint of the recipient.</span>

<span class="k">using</span> <span class="n">ThirdPartyCapId</span> <span class="l">= Object</span>;
<span class="c1"># **(level 3)**</span>
<span class="c1">#</span>
<span class="c1"># The information needed to connect to a third party and accept a capability from it.</span>
<span class="c1">#</span>
<span class="c1"># In a network where each vat has a public/private key pair, this could be a combination of the</span>
<span class="c1"># third party&#39;s public key fingerprint, hints on how to connect to the third party (e.g. an IP</span>
<span class="c1"># address), and the question ID used in the corresponding `Provide` mesasge sent to that third party</span>
<span class="c1"># (used to identify which capability to pick up).</span>

<span class="k">using</span> <span class="n">JoinKeyPart</span> <span class="l">= Object</span>;
<span class="c1"># **(level 4)**</span>
<span class="c1">#</span>
<span class="c1"># A piece of a secret key.  One piece is sent along each path that is expected to lead to the same</span>
<span class="c1"># place.  Once the pieces are combined, a direct connection may be formed between the sender and</span>
<span class="c1"># the receiver, bypassing any men-in-the-middle along the paths.  See the `Join` message type.</span>
<span class="c1">#</span>
<span class="c1"># The motivation for Joins is discussed under &quot;Supporting Equality&quot; in the &quot;Unibus&quot; protocol</span>
<span class="c1"># sketch: http://www.erights.org/elib/distrib/captp/unibus.html</span>
<span class="c1">#</span>
<span class="c1"># In a network where each vat has a public/private key pair and each vat forms no more than one</span>
<span class="c1"># connection to each other vat, Joins will rarely -- perhaps never -- be needed, as objects never</span>
<span class="c1"># need to be transparently proxied and references to the same object sent over the same connection</span>
<span class="c1"># have the same export ID.  Thus, a successful join requires only checking that the two objects</span>
<span class="c1"># come from the same connection and have the same ID, and then completes immediately.</span>
<span class="c1">#</span>
<span class="c1"># However, in networks where two vats may form more than one connection between each other, or</span>
<span class="c1"># where proxying of objects occurs, joins are necessary.</span>
<span class="c1">#</span>
<span class="c1"># Typically, each JoinKeyPart would include a fixed-length data value such that all value parts</span>
<span class="c1"># XOR&#39;d together forms a shared secret which can be used to form an encrypted connection between</span>
<span class="c1"># the joiner and the joined object&#39;s host.  Each JoinKeyPart should also include an indication of</span>
<span class="c1"># how many parts to expect and a hash of the shared secret (used to match up parts).</span>

<span class="k">using</span> <span class="n">JoinAnswer</span> <span class="l">= Object</span>;
<span class="c1"># **(level 4)**</span>
<span class="c1">#</span>
<span class="c1"># Information returned in the answer to a `Join` message, needed by the joiner in order to form a</span>
<span class="c1"># direct connection to a joined object.  This might simply be the address of the joined object&#39;s</span>
<span class="c1"># host vat, since the `JoinKey` has already been communicated so the two vats already have a shared</span>
<span class="c1"># secret to use to authenticate each other.</span>
<span class="c1">#</span>
<span class="c1"># The `JoinAnswer` should also contain information that can be used to detect when the Join</span>
<span class="c1"># requests ended up reaching different objects, so that this situation can be detected easily.</span>
<span class="c1"># This could be a simple matter of including a sequence number -- if the joiner receives two</span>
<span class="c1"># `JoinAnswer`s with sequence number 0, then they must have come from different objects and the</span>
<span class="c1"># whole join is a failure.</span>

<span class="c1"># ========================================================================================</span>
<span class="c1"># Network interface sketch</span>
<span class="c1">#</span>
<span class="c1"># The interfaces below are meant to be pseudo-code to illustrate how the details of a particular</span>
<span class="c1"># vat network might be abstracted away.  They are written like Cap&#39;n Proto interfaces, but in</span>
<span class="c1"># practice you&#39;d probably define these interfaces manually in the target programming language.  A</span>
<span class="c1"># Cap&#39;n Proto RPC implementation should be able to use these interfaces without knowing the</span>
<span class="c1"># definitions of the various network-specific parameters defined above.</span>

<span class="k">interface</span> <span class="n">VatNetwork</span> {
  <span class="c1"># Represents a vat network, with the ability to connect to particular vats and receive</span>
  <span class="c1"># connections from vats.</span>
  <span class="c1">#</span>
  <span class="c1"># Note that methods returning a `Connection` may return a pre-existing `Connection`, and the</span>
  <span class="c1"># caller is expected to find and share state with existing users of the connection.</span>

  <span class="c1"># Level 0 features -----------------------------------------------</span>

  <span class="n">connectToHostOf</span>(<span class="n">ref</span> <span class="nc">:SturdyRef</span>) <span class="nc">:Connection</span>;
  <span class="c1"># Connect to a host which can restore the given SturdyRef.  The transport should return a</span>
  <span class="c1"># promise which does not resolve until authentication has completed, but allows messages to be</span>
  <span class="c1"># pipelined in before that; the transport either queues these messages until authenticated, or</span>
  <span class="c1"># sends them encrypted such that only the authentic vat would be able to decrypt them.  The</span>
  <span class="c1"># latter approach avoids a round trip for authentication.</span>
  <span class="c1">#</span>
  <span class="c1"># Once connected, the caller should start by sending a `Restore` message.</span>

  <span class="n">acceptConnectionAsRefHost</span>() <span class="nc">:Connection</span>;
  <span class="c1"># Wait for the next incoming connection and return it.  Only connections formed by</span>
  <span class="c1"># connectToHostOf() are returned by this method.</span>
  <span class="c1">#</span>
  <span class="c1"># Once connected, the first received message will usually be a `Restore`.</span>

  <span class="c1"># Level 4 features -----------------------------------------------</span>

  <span class="n">newJoiner</span>(<span class="n">count</span> <span class="nc">:UInt32</span>)<span class="nc">: NewJoinerResponse</span>;
  <span class="c1"># Prepare a new Join operation, which will eventually lead to forming a new direct connection</span>
  <span class="c1"># to the host of the joined capability.  `count` is the number of capabilities to join.</span>

  <span class="k">struct</span> <span class="n">NewJoinerResponse</span> {
    <span class="n">joinKeyParts</span> <span class="nc">:List(JoinKeyPart)</span>;
    <span class="c1"># Key parts to send in Join messages to each capability.</span>

    <span class="n">joiner</span> <span class="nc">:Joiner</span>;
    <span class="c1"># Used to establish the final connection.</span>
  }

  <span class="k">interface</span> <span class="n">Joiner</span> {
    <span class="n">addJoinAnswer</span>(<span class="n">answer</span> <span class="nc">:JoinAnswer</span>) <span class="nc">:Void</span>;
    <span class="c1"># Add a JoinAnswer received in response to one of the `Join` messages.  All `JoinAnswer`s</span>
    <span class="c1"># returned from all paths must be added before trying to connect.</span>

    <span class="n">connect</span>() <span class="nc">:ConnectionAndProvisionId</span>;
    <span class="c1"># Try to form a connection to the joined capability&#39;s host, verifying that it has received</span>
    <span class="c1"># all of the JoinKeyParts.  Once the connection is formed, the caller should send an `Accept`</span>
    <span class="c1"># message on it with the specified `ProvisionId` in order to receive the final capability.</span>
  }

  <span class="n">acceptConnectionFromJoiner</span>(<span class="n">parts</span><span class="nc">: List(JoinKeyPart)</span>, <span class="n">paths</span> <span class="nc">:List(VatPath)</span>)
      <span class="nc">:ConnectionAndProvisionId</span>;
  <span class="c1"># Called on a joined capability&#39;s host to receive the connection from the joiner, once all</span>
  <span class="c1"># key parts have arrived.  The caller should expect to receive an `Accept` message over the</span>
  <span class="c1"># connection with the given ProvisionId.</span>
}

<span class="k">interface</span> <span class="n">Connection</span> {
  <span class="c1"># Level 0 features -----------------------------------------------</span>

  <span class="n">send</span>(<span class="n">message</span> <span class="nc">:Message</span>) <span class="nc">:Void</span>;
  <span class="c1"># Send the message.  Returns successfully when the message (and all preceding messages) has</span>
  <span class="c1"># been acknowledged by the recipient.</span>

  <span class="n">receive</span>() <span class="nc">:Message</span>;
  <span class="c1"># Receive the next message, and acknowledges receipt to the sender.  Messages are received in</span>
  <span class="c1"># the order in which they are sent.</span>

  <span class="c1"># Level 3 features -----------------------------------------------</span>

  <span class="n">introduceTo</span>(<span class="n">recipient</span> <span class="nc">:Connection</span>) <span class="nc">:IntroductionInfo</span>;
  <span class="c1"># Call before starting a three-way introduction, assuming a `Provide` message is to be sent on</span>
  <span class="c1"># this connection and a `ThirdPartyCapId` is to be sent to `recipient`.</span>

  <span class="k">struct</span> <span class="n">IntroductionInfo</span> {
    <span class="n">sendToRecipient</span> <span class="nc">:ThirdPartyCapId</span>;
    <span class="n">sendToTarget</span> <span class="nc">:RecipientId</span>;
  }

  <span class="n">connectToIntroduced</span>(<span class="n">capId</span><span class="nc">: ThirdPartyCapId</span>) <span class="nc">:ConnectionAndProvisionId</span>;
  <span class="c1"># Given a ThirdPartyCapId received over this connection, connect to the third party.  The</span>
  <span class="c1"># caller should then send an `Accept` message over the new connection.</span>

  <span class="n">acceptIntroducedConnection</span>(<span class="n">recipientId</span><span class="nc">: RecipientId</span>)<span class="nc">: Connection</span>
<span class="nc">  # Given a RecipientId received in a `Provide` message on this `Connection`</span>, <span class="n">wait</span> <span class="n">for</span> <span class="n">the</span>
  <span class="c1"># recipient to connect, and return the connection formed.  Usually, the first message received</span>
  <span class="c1"># on the new connection will be an `Accept` message.</span>
}

<span class="n">sturct</span> <span class="n">ConnectionAndProvisionId</span> {
  <span class="c1"># **(level 3)**</span>

  <span class="n">connection</span> <span class="nc">:Connection</span>;
  <span class="c1"># Connection on which to issue `Accept` message.</span>

  <span class="n">provision</span> <span class="nc">:ProvisionId</span>;
  <span class="c1"># `ProvisionId` to send in the `Accept` message.</span>
}
</pre></div>
  </div>
</body>
