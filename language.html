<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=480">

    <link rel="stylesheet" type="text/css" media="screen" href="/capnproto/stylesheets/stylesheet.css">

    <title>Cap'n Proto: Schema Language</title>

    <script type="text/javascript" src="/capnproto/javascripts/main.js"></script>
  </head>

  <body class="desktop">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <img src="/capnproto/images/captain_proto.png">
        <div id="infinitely_faster">
          <img src="/capnproto/images/infinitely_faster.png">
        </div>
      </header>
      <a id="discuss_banner" href="https://groups.google.com/group/capnproto">Discuss on Groups</a>
      <a id="forkme_banner" href="https://github.com/kentonv/capnproto">View on GitHub</a>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">

      <section id="menu">
        <ul>
          <li><a href="/capnproto/index.html">Introduction</a></li>
          <li><a href="/capnproto/news/">News</a></li>
          <li><a href="/capnproto/install.html">Installation</a></li>
          <li><a href="/capnproto/language.html">Schema Language</a></li>
          <li><a href="/capnproto/encoding.html">Encoding</a></li>
          <li><a href="/capnproto/rpc.html">RPC Protocol</a></li>
          <li><a href="/capnproto/cxx.html">C++ Runtime</a></li>
          <li><a href="/capnproto/otherlang.html">Other Languages</a></li>
        </ul>
      </section>
      <section id="main_content" class="inner">

<h1 id='schema_language'>Schema Language</h1>

<p>Like Protocol Buffers and Thrift (but unlike JSON or MessagePack), Cap&#8217;n Proto messages are strongly-typed and not self-describing. You must define your message structure in a special language, then invoke the Cap&#8217;n Proto compiler (<code>capnp compile</code>) to generate source code to manipulate that message type in your desired language.</p>

<p>For example:</p>
<div class='highlight'><pre><code class='python'><span class='c'># unique file ID, generated by `capnp id`</span>
<span class='nd'>@0xdbb9ad1f14bf0b36</span><span class='p'>;</span>

<span class='n'>struct</span> <span class='n'>Person</span> <span class='p'>{</span>
  <span class='n'>name</span> <span class='nd'>@0</span> <span class='p'>:</span><span class='n'>Text</span><span class='p'>;</span>
  <span class='n'>birthdate</span> <span class='nd'>@3</span> <span class='p'>:</span><span class='n'>Date</span><span class='p'>;</span>

  <span class='n'>email</span> <span class='nd'>@1</span> <span class='p'>:</span><span class='n'>Text</span><span class='p'>;</span>
  <span class='n'>phones</span> <span class='nd'>@2</span> <span class='p'>:</span><span class='n'>List</span><span class='p'>(</span><span class='n'>PhoneNumber</span><span class='p'>);</span>

  <span class='n'>struct</span> <span class='n'>PhoneNumber</span> <span class='p'>{</span>
    <span class='n'>number</span> <span class='nd'>@0</span> <span class='p'>:</span><span class='n'>Text</span><span class='p'>;</span>
    <span class='nb'>type</span> <span class='nd'>@1</span> <span class='p'>:</span><span class='n'>Type</span><span class='p'>;</span>

    <span class='n'>enum</span> <span class='n'>Type</span> <span class='p'>{</span>
      <span class='n'>mobile</span> <span class='nd'>@0</span><span class='p'>;</span>
      <span class='n'>home</span> <span class='nd'>@1</span><span class='p'>;</span>
      <span class='n'>work</span> <span class='nd'>@2</span><span class='p'>;</span>
    <span class='p'>}</span>
  <span class='p'>}</span>
<span class='p'>}</span>

<span class='n'>struct</span> <span class='n'>Date</span> <span class='p'>{</span>
  <span class='n'>year</span> <span class='nd'>@0</span> <span class='p'>:</span><span class='n'>Int16</span><span class='p'>;</span>
  <span class='n'>month</span> <span class='nd'>@1</span> <span class='p'>:</span><span class='n'>UInt8</span><span class='p'>;</span>
  <span class='n'>day</span> <span class='nd'>@2</span> <span class='p'>:</span><span class='n'>UInt8</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre></div>
<p>Some notes:</p>

<ul>
<li>Types come after names. The name is by far the most important thing to see, especially when quickly skimming, so we put it up front where it is most visible. Sorry, C got it wrong.</li>

<li>The <code>@N</code> annotations show how the protocol evolved over time, so that the system can make sure to maintain compatibility with older versions. Fields (and enumerants, and interface methods) must be numbered consecutively starting from zero in the order in which they were added. In this example, it looks like the <code>birthdate</code> field was added to the <code>Person</code> structure recently &#8211; its number is higher than the <code>email</code> and <code>phones</code> fields. Unlike Protobufs, you cannot skip numbers when defining fields &#8211; but there was never any reason to do so anyway.</li>
</ul>

<h2 id='language_reference'>Language Reference</h2>

<h3 id='comments'>Comments</h3>

<p>Comments are indicated by hash signs and extend to the end of the line:</p>
<div class='highlight'><pre><code class='capnp'><span class='c1'># This is a comment.</span>
</code></pre></div>
<p>Comments meant as documentation should appear <em>after</em> the declaration, either on the same line, or on a subsequent line. Doc comments for aggregate definitions should appear on the line after the opening brace.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Date</span> {
  <span class='c1'># A standard Gregorian calendar date.</span>

  <span class='n'>year</span> <span class='nd'>@0</span> <span class='nc'>:Int16</span>;
  <span class='c1'># The year.  Must include the century.</span>
  <span class='c1'># Negative value indicates BC.</span>

  <span class='n'>month</span> <span class='nd'>@1</span> <span class='nc'>:UInt8</span>;   <span class='c1'># Month number, 1-12.</span>
  <span class='n'>day</span> <span class='nd'>@2</span> <span class='nc'>:UInt8</span>;     <span class='c1'># Day number, 1-30.</span>
}
</code></pre></div>
<p>Placing the comment <em>after</em> the declaration rather than before makes the code more readable, especially when doc comments grow long. You almost always need to see the declaration before you can start reading the comment.</p>

<h3 id='builtin_types'>Built-in Types</h3>

<p>The following types are automatically defined:</p>

<ul>
<li><strong>Void:</strong> <code>Void</code></li>

<li><strong>Boolean:</strong> <code>Bool</code></li>

<li><strong>Integers:</strong> <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>

<li><strong>Unsigned integers:</strong> <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></li>

<li><strong>Floating-point:</strong> <code>Float32</code>, <code>Float64</code></li>

<li><strong>Blobs:</strong> <code>Text</code>, <code>Data</code></li>

<li><strong>Lists:</strong> <code>List(T)</code></li>
</ul>

<p>Notes:</p>

<ul>
<li>The <code>Void</code> type has exactly one possible value, and thus can be encoded in zero bits. It is rarely used, but can be useful as a union member.</li>

<li><code>Text</code> is always UTF-8 encoded and NUL-terminated.</li>

<li><code>Data</code> is a completely arbitrary sequence of bytes.</li>

<li><code>List</code> is a parameterized type, where the parameter is the element type. For example, <code>List(Int32)</code>, <code>List(Person)</code>, and <code>List(List(Text))</code> are all valid.</li>
</ul>

<h3 id='structs'>Structs</h3>

<p>A struct has a set of named, typed fields, numbered consecutively starting from zero.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Person</span> {
  <span class='n'>name</span> <span class='nd'>@0</span> <span class='nc'>:Text</span>;
  <span class='n'>email</span> <span class='nd'>@1</span> <span class='nc'>:Text</span>;
}
</code></pre></div>
<p>Fields can have default values:</p>

<p><div class='highlight'><pre><code class='capnp'><span class='n'>foo</span> <span class='nd'>@0</span> <span class='nc'>:Int32 </span><span class='l'>= 123</span>;
<span class='n'>bar</span> <span class='nd'>@1</span> <span class='nc'>:Text </span><span class='l'>= &quot;blah&quot;</span>;
<span class='n'>baz</span> <span class='nd'>@2</span> <span class='nc'>:List(Bool) </span><span class='l'>= [ true, false, false, true ]</span>;
<span class='n'>qux</span> <span class='nd'>@3</span> <span class='nc'>:Person </span><span class='l'>= (name = &quot;Bob&quot;, email = &quot;bob@example.com&quot;)</span>;
<span class='n'>corge</span> <span class='nd'>@4</span> <span class='nc'>:Void </span><span class='l'>= void</span>;
</code></pre></div></p>

<h3 id='unions'>Unions</h3>

<p>A union is two or more fields of a struct which are stored in the same location. Only one of these fields can be set at a time, and a separate tag is maintained to track which one is currently set. Unlike in C, unions are not types, they are simply properties of fields, therefore union declarations do not look like types.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Person</span> {
  <span class='c1'># ...</span>

  <span class='n'>employment</span> <span class='nd'>@4</span> <span class='k'>union</span> {
    <span class='n'>unemployed</span> <span class='nd'>@5</span> <span class='nc'>:Void</span>;
    <span class='n'>employer</span> <span class='nd'>@6</span> <span class='nc'>:Company</span>;
    <span class='n'>school</span> <span class='nd'>@7</span> <span class='nc'>:School</span>;
    <span class='n'>selfEmployed</span> <span class='nd'>@8</span> <span class='nc'>:Void</span>;
    <span class='c1'># We assume that a person is only one of these.</span>
  }
}
</code></pre></div>
<p>Notes:</p>

<ul>
<li>
<p>Unions and their members are numbered in the same number space as fields of the containing struct. Remember that the purpose of the numbers is to indicate the evolution order of the struct. The system needs to know when the union and each of its members was declared relative to the non-union fields. Also note that no more than one element of the union is allowed to have a number less than the union&#8217;s number, as unionizing two or more pre-existing fields would change their layout.</p>
</li>

<li>
<p>Notice that we used the &#8220;useless&#8221; <code>Void</code> type here. We don&#8217;t have any extra information to store for the <code>unemployed</code> or <code>selfEmployed</code> cases, but we still want the union to distinguish these states from others.</p>
</li>
</ul>

<p><strong>Wait, why aren&#8217;t unions first-class types?</strong></p>

<p>Requiring unions to be declared inside a struct, rather than living as free-standing types, has some important advantages:</p>

<ul>
<li>
<p>If unions were first-class types, then either (a) all unions would have to have a fixed size of 18 bytes (a data word, a pointer, and a 2-byte tag) regardless of their members; or (b) unions would have to be separate objects embedded by pointer, adding 10-14 bytes of overhead to every union (the pointer plus 2-6 bytes lost to padding).</p>

<p>If neither of these conditions were true, then adding a new field to a union would potentially alter the layout of any struct containing an instance of that union in a backwards-incompatible way. On the other hand, if each union type is bound to its containing struct, then its fields can be numbered in the same space as the struct&#8217;s fields, which allows the layout algorithm to extend the union for new fields without disrupting the positioning of existing fields. All in all, space is saved.</p>
</li>

<li>
<p>A free-standing union would be a liability for protocol evolution, because no additional data can be attached to it later on. Consider, for example, a type which represents a parser token. This type is naturally a union: it may be a keyword, identifier, numeric literal, quoted string, etc. So the author defines it as a union, and the type is used widely. Later on, the developer wants to attach information to the token indicating its line and column number in the source file. Unfortunately, this is impossible without updating all users of the type, because the new information ought to apply to <em>all</em> token instances, not just specific members of the union. On the other hand, if unions must be embedded within structs, it is always possible to add new fields to the struct later on.</p>
</li>

<li>
<p>When evolving a protocol it is common to discover that some existing field really should have been enclosed in a union, because new fields being added are mutually exclusive with it. With Cap&#8217;n Proto&#8217;s unions, it is actually possible to &#8220;retroactively unionize&#8221; such a field without changing its layout. This allows you to continue being able to read old data without wasting space when writing new data. This is only possible when unions are declared within their containing struct.</p>
</li>
</ul>

<p>Cap&#8217;n Proto&#8217;s unconventional approach to unions provides these advantages without any real down side: where you would conventionally define a free-standing union type, in Cap&#8217;n Proto you may simply define a struct type that contains only that union, and you have achieved the same effect. Thus, aside from being slightly unintuitive, it is strictly superior.</p>

<h3 id='dynamicallytyped_fields'>Dynamically-typed Fields</h3>

<p>A struct may have a field with type <code>Object</code>. This field&#8217;s value can be of any pointer type &#8211; i.e. any struct, interface, list, or blob. This is essentially like a <code>void*</code> in C.</p>

<h3 id='enums'>Enums</h3>

<p>An enum is a type with a small finite set of symbolic values.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>enum</span> <span class='n'>Rfc3092Variable</span> {
  <span class='n'>foo</span> <span class='nd'>@0</span>;
  <span class='n'>bar</span> <span class='nd'>@1</span>;
  <span class='n'>baz</span> <span class='nd'>@2</span>;
  <span class='n'>qux</span> <span class='nd'>@3</span>;
  <span class='c1'># ...</span>
}
</code></pre></div>
<p>Like fields, enumerants must be numbered sequentially starting from zero. In languages where enums have numeric values, these numbers will be used, but in general Cap&#8217;n Proto enums should not be considered numeric.</p>

<h3 id='interfaces'>Interfaces</h3>

<p>An interface has a collection of methods, each of which takes some parameters and returns a result. Like struct fields, methods are numbered.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>interface</span> <span class='n'>Directory</span> {
  <span class='n'>list</span> <span class='nd'>@0</span> () <span class='nc'>:List(FileInfo)</span>;
  <span class='n'>create</span> <span class='nd'>@1</span> (<span class='n'>name</span> <span class='nc'>:Text</span>) <span class='nc'>:FileInfo</span>;
  <span class='n'>open</span> <span class='nd'>@2</span> (<span class='n'>name</span> <span class='nc'>:Text</span>) <span class='nc'>:FileInfo</span>;
  <span class='n'>delete</span> <span class='nd'>@3</span> (<span class='n'>name</span> <span class='nc'>:Text</span>) <span class='nc'>:Void</span>;
  <span class='n'>link</span> <span class='nd'>@4</span> (<span class='n'>name</span> <span class='nc'>:Text</span>, <span class='n'>file</span> <span class='nc'>:File</span>) <span class='nc'>:Void</span>;
}

<span class='k'>struct</span> <span class='n'>FileInfo</span> {
  <span class='n'>name</span> <span class='nd'>@0</span> <span class='nc'>:Text</span>;
  <span class='n'>size</span> <span class='nd'>@1</span> <span class='nc'>:UInt64</span>;
  <span class='n'>file</span> <span class='nd'>@2</span> <span class='nc'>:File</span>;   <span class='c1'># A pointer to a File.</span>
}

<span class='k'>interface</span> <span class='n'>File</span> {
  <span class='n'>read</span> <span class='nd'>@0</span> (<span class='n'>startAt</span> <span class='nc'>:UInt64 </span><span class='l'>= 0</span>, <span class='n'>amount</span> <span class='nc'>:UInt64 </span><span class='l'>= 0xffffffffffffffff</span>) <span class='nc'>:Data</span>;
  <span class='c1'># Default params = read entire file.</span>

  <span class='n'>write</span> <span class='nd'>@1</span> (<span class='n'>startAt</span> <span class='nc'>:UInt64</span>, <span class='n'>data</span> <span class='nc'>:Data</span>) <span class='nc'>:Void</span>;
  <span class='n'>truncate</span> <span class='nd'>@2</span> (<span class='n'>size</span> <span class='nc'>:UInt64</span>) <span class='nc'>:Void</span>;
}
</code></pre></div>
<p>Notice something interesting here: <code>FileInfo</code> is a struct, but it contains a <code>File</code>, which is an interface. Structs (and primitive types) are passed over RPC by value, but interfaces are passed by reference. So when <code>Directory.open</code> is called remotely, the content of a <code>FileInfo</code> (including values for <code>name</code> and <code>size</code>) is transmitted back, but for the <code>file</code> field, only the address of some remote <code>File</code> object is sent.</p>

<p>When an address of an object is transmitted, the RPC system automatically manages making sure that the recipient gets permission to call the addressed object &#8211; because if the recipient wasn&#8217;t meant to have access, the sender shouldn&#8217;t have sent the reference in the first place. This makes it very easy to develop secure protocols with Cap&#8217;n Proto &#8211; you almost don&#8217;t need to think about access control at all. This feature is what makes Cap&#8217;n Proto a &#8220;capability-based&#8221; RPC system &#8211; a reference to an object inherently represents a &#8220;capability&#8221; to access it.</p>

<h3 id='constants'>Constants</h3>

<p>You can define constants in Cap&#8217;n Proto. These don&#8217;t affect what is sent on the wire, but they will be included in the generated code.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>const</span> <span class='n'>pi</span> <span class='nc'>:Float32 </span><span class='l'>= 3.14159</span>;
<span class='k'>const</span> <span class='n'>bob</span> <span class='nc'>:Person </span><span class='l'>= (name = &quot;Bob&quot;, email = &quot;bob@example.com&quot;)</span>;
</code></pre></div>
<h3 id='nesting_scope_and_aliases'>Nesting, Scope, and Aliases</h3>

<p>You can nest constant, alias, and type definitions inside structs and interfaces (but not enums). This has no effect on any definition involved except to define the scope of its name. So in Java terms, inner classes are always &#8220;static&#8221;. To name a nested type from another scope, separate the path with <code>.</code>s.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Foo</span> {
  <span class='k'>struct</span> <span class='n'>Bar</span> {
    <span class='c1'>#...</span>
  }
  <span class='n'>bar</span> <span class='nd'>@0</span> <span class='nc'>:Bar</span>;
}

<span class='k'>struct</span> <span class='n'>Baz</span> {
  <span class='n'>bar</span> <span class='nd'>@0</span> <span class='nc'>:Foo.Bar</span>;
}
</code></pre></div>
<p>If typing long scopes becomes cumbersome, you can use <code>using</code> to declare an alias.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Qux</span> {
  <span class='k'>using</span> <span class='n'>Foo.Bar</span>;
  <span class='n'>bar</span> <span class='nd'>@0</span> <span class='nc'>:Bar</span>;
}

<span class='k'>struct</span> <span class='n'>Corge</span> {
  <span class='k'>using</span> <span class='n'>T</span> <span class='l'>= Foo.Bar</span>;
  <span class='n'>bar</span> <span class='nd'>@0</span> <span class='nc'>:T</span>;
}
</code></pre></div>
<h3 id='imports'>Imports</h3>

<p>An <code>import</code> expression names the scope of some other file:</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>struct</span> <span class='n'>Foo</span> {
  <span class='c1'># Use type &quot;Baz&quot; defined in bar.capnp.</span>
  <span class='n'>baz</span> <span class='nd'>@0</span> <span class='nc'>:import &quot;bar.capnp&quot;.Baz</span>;
}
</code></pre></div>
<p>Of course, typically it&#8217;s more readable to define an alias:</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>using</span> <span class='n'>Bar</span> <span class='l'>= import &quot;bar.capnp&quot;</span>;

<span class='k'>struct</span> <span class='n'>Foo</span> {
  <span class='c1'># Use type &quot;Baz&quot; defined in bar.capnp.</span>
  <span class='n'>baz</span> <span class='nd'>@0</span> <span class='nc'>:Bar.Baz</span>;
}
</code></pre></div>
<p>Or even:</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>using</span> <span class='k'>import</span> &quot;<span class='n'>bar.capnp</span>&quot;.<span class='n'>Baz</span>;

<span class='k'>struct</span> <span class='n'>Foo</span> {
  <span class='n'>baz</span> <span class='nd'>@0</span> <span class='nc'>:Baz</span>;
}
</code></pre></div>
<p>The above imports specify relative paths. If the path begins with a <code>/</code>, it is absolute &#8211; in this case, the <code>capnp</code> tool searches for the file in each of the search path directories specified with <code>-I</code>.</p>

<h3 id='annotations'>Annotations</h3>

<p>Sometimes you want to attach extra information to parts of your protocol that isn&#8217;t part of the Cap&#8217;n Proto language. This information might control details of a particular code generator, or you might even read it at run time to assist in some kind of dynamic message processing. For example, you might create a field annotation which means &#8220;hide from the public&#8221;, and when you send a message to an external user, you might invoke some code first that iterates over your message and removes all of these hidden fields.</p>

<p>You may declare annotations and use them like so:</p>
<div class='highlight'><pre><code class='capnp'><span class='c1'># Declare an annotation &#39;foo&#39; which applies to struct and enum types.</span>
<span class='k'>annotation</span> <span class='n'>foo</span>(<span class='k'>struct</span>, <span class='k'>enum</span>) <span class='nc'>:Text</span>;

<span class='c1'># Apply &#39;foo&#39; to to MyType.</span>
<span class='k'>struct</span> <span class='n'>MyType</span> <span class='na'>$foo(&quot;bar&quot;) </span>{
  <span class='c1'># ...</span>
}
</code></pre></div>
<p>The possible targets for an annotation are: <code>file</code>, <code>struct</code>, <code>field</code>, <code>union</code>, <code>enum</code>, <code>enumerant</code>, <code>interface</code>, <code>method</code>, <code>parameter</code>, <code>annotation</code>, <code>const</code>. You may also specify <code>*</code> to cover them all.</p>
<div class='highlight'><pre><code class='capnp'><span class='c1'># &#39;baz&#39; can annotate anything!</span>
<span class='k'>annotation</span> <span class='n'>baz</span>(*) <span class='nc'>:Int32</span>;

<span class='na'>$baz(1)</span>;  <span class='c1'># Annotate the file.</span>

<span class='k'>struct</span> <span class='n'>MyStruct</span> <span class='na'>$baz(2) </span>{
  <span class='n'>myField</span> <span class='nd'>@0</span> <span class='nc'>:Text </span><span class='l'>= &quot;default&quot; </span><span class='na'>$baz(3)</span>;
  <span class='n'>myUnion</span> <span class='nd'>@1</span> <span class='k'>union</span> <span class='na'>$baz(4) </span>{
    <span class='c1'># ...</span>
  }
}

<span class='k'>enum</span> <span class='n'>MyEnum</span> <span class='na'>$baz(5) </span>{
  <span class='n'>myEnumerant</span> <span class='nd'>@0</span> <span class='na'>$baz(6)</span>;
}

<span class='k'>interface</span> <span class='n'>MyInterface</span> <span class='na'>$baz(7) </span>{
  <span class='n'>myMethod</span>(<span class='n'>myParam</span> <span class='nc'>:Text </span><span class='na'>$baz(9)</span>) <span class='nc'>:Void </span><span class='na'>$baz(8)</span>;
}

<span class='k'>annotation</span> <span class='n'>myAnnotation</span>(<span class='k'>struct</span>) <span class='nc'>:Int32 </span><span class='na'>$baz(10)</span>;
<span class='k'>const</span> <span class='n'>myConst</span> <span class='nc'>:Int32 </span><span class='l'>= 123 </span><span class='na'>$baz(11)</span>;
</code></pre></div>
<p><code>Void</code> annotations can omit the value. Struct-typed annotations are also allowed.</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>annotation</span> <span class='n'>qux</span>(<span class='k'>struct</span>, <span class='n'>field</span>) <span class='nc'>:Void</span>;

<span class='k'>struct</span> <span class='n'>MyStruct</span> <span class='na'>$qux </span>{
  <span class='n'>string</span> <span class='nd'>@0</span> <span class='nc'>:Text </span><span class='na'>$qux</span>;
  <span class='n'>number</span> <span class='nd'>@1</span> <span class='nc'>:Int32 </span><span class='na'>$qux</span>;
}

<span class='k'>annotation</span> <span class='n'>corge</span>(<span class='n'>file</span>) <span class='nc'>:MyStruct</span>;

<span class='na'>$corge(string = &quot;hello&quot;, number = 123)</span>;
</code></pre></div>
<h3 id='unique_ids'>Unique IDs</h3>

<p>A Cap&#8217;n Proto file must have a unique 64-bit ID, and each type and annotation defined therein may also have an ID. Use <code>capnp id</code> to generate a new ID randomly. ID specifications begin with <code>@</code>:</p>
<div class='highlight'><pre><code class='capnp'><span class='c1'># file ID</span>
<span class='nd'>@0xdbb9ad1f14bf0b36</span>;

<span class='k'>struct</span> <span class='n'>Foo</span> <span class='nd'>@0x8db435604d0d3723</span> {
  <span class='c1'># ...</span>
}

<span class='k'>enum</span> <span class='n'>Bar</span> <span class='nd'>@0xb400f69b5334aab3</span> {
  <span class='c1'># ...</span>
}

<span class='k'>interface</span> <span class='n'>Baz</span> <span class='nd'>@0xf7141baba3c12691</span> {
  <span class='c1'># ...</span>
}

<span class='k'>annotation</span> <span class='n'>qux</span> <span class='nd'>@0xf8a1bedf44c89f00</span> (<span class='n'>field</span>) <span class='nc'>:Text</span>;
</code></pre></div>
<p>If you omit the ID for a type or annotation, one will be assigned automatically. This default ID is derived by taking the first 8 bytes of the MD5 hash of the parent scope&#8217;s ID concatenated with the declaration&#8217;s name (where the &#8220;parent scope&#8221; is the file for top-level delarations, or the outer type for nested declarations). You can see the automatically-generated IDs by &#8220;compiling&#8221; your file with the <code>-ocapnp</code> flag, which echos the schema back to the terminal annotated with extra information, e.g. <code>capnp compile -ocapnp myschema.capnp</code>. In general, you would only specify an explicit ID for a declaration if that declaration has been renamed or moved and you want the ID to stay the same for backwards-compatibility.</p>

<p>IDs exist to provide a relatively short yet unambiguous way to refer to a type or annotation from another context. They may be used for representing schemas, for tagging dynamically-typed fields, etc. Most languages prefer instead to define a symbolic global namespace e.g. full of &#8220;packages&#8221;, but this would have some important disadvantages in the context of Cap&#8217;n Proto:</p>

<ul>
<li>Programmers often feel the need to change symbolic names and organization in order to make their code cleaner, but the renamed code should still work with existing encoded data.</li>

<li>It&#8217;s easy for symbolic names to collide, and these collisions could be hard to detect in a large distributed system with many different binaries using different versions of protocols.</li>

<li>Fully-qualified type names may be large and waste space when transmitted on the wire.</li>
</ul>

<p>Note that IDs are 64-bit (actually, 63-bit, as the first bit is always 1). Random collisions are possible, but unlikely &#8211; there would have to be on the order of a billion types before this becomes a real concern. Collisions from misuse (e.g. copying an example without changing the ID) are much more likely.</p>

<h2 id='evolving_your_protocol'>Evolving Your Protocol</h2>

<p>A protocol can be changed in the following ways without breaking backwards-compatibility:</p>

<ul>
<li>New types, constants, and aliases can be added anywhere, since they obviously don&#8217;t affect the encoding of any existing type.</li>

<li>New fields, values, and methods may be added to structs, enums, and interfaces, respectively, with the numbering rules described earlier.</li>

<li>New parameters may be added to a method. The new parameters must be added to the end of the parameter list and must have default values.</li>

<li>Any symbolic name can be changed, as long as the ordinal numbers stay the same.</li>

<li>Types definitions can be moved to different scopes.</li>

<li>A field of type <code>List(T)</code>, where <code>T</code> is a primitive type, blob, or list, may be changed to type <code>List(U)</code>, where <code>U</code> is a struct type whose <code>@0</code> field is of type <code>T</code>. This rule is useful when you realize too late that you need to attach some extra data to each element of your list. Without this rule, you would be stuck defining parallel lists, which are ugly and error-prone.</li>
</ul>

<p>Any other change should be assumed NOT to be safe. Also, these rules only apply to the Cap&#8217;n Proto native encoding. It is sometimes useful to transcode Cap&#8217;n Proto types to other formats, like JSON, which may have different rules (e.g., field names cannot change in JSON).</p>
<script type="text/javascript">setupSidebar()</script>
        <div style="clear: both;"></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cap'n Proto maintained by <a href="https://github.com/kentonv">kentonv</a>
          <span class="gplus-followbutton"><span class="g-follow" data-annotation="bubble" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
          <a href="https://www.gittip.com/kentonv/"><img class="gittip15" src="/capnproto/images/gittip15.png" alt="Gittip"></a></p>
        <p>Design by <a href="http://www.starfruit-cafe.net/blog">sailorhg</a> ∙ Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    <!-- Google+ follow button. -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>

    <!-- Google Analytics. -->
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-39711112-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>
  </body>
</html>

