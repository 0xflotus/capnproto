<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=480">

    <link rel="stylesheet" type="text/css" media="screen" href="/capnproto/next/stylesheets/stylesheet.css">

    <title>Cap'n Proto: News</title>

    <script type="text/javascript" src="/capnproto/next/javascripts/main.js"></script>
  </head>

  <body class="desktop">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <img src="/capnproto/next/images/logo.png">
        <div id="infinitely_faster">
          <img src="/capnproto/next/images/infinitely_faster.png">
        </div>
      </header>
      <a id="discuss_banner" href="https://groups.google.com/group/capnproto">Discuss on Groups</a>
      <a id="forkme_banner" href="https://github.com/kentonv/capnproto">View on GitHub</a>
    </div>

    
    <div id="next_banner">
      <h1>PREVIEW</h1>
      <p>You are looking at the site as it will appear after the next release.  This is a draft
         version that may be incomplete, buggy, or not yet applicable.  To look at the current
         site, <a href="../">click here</a>.
    </div>
    

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">

      <section id="menu">
        <ul>
          <li><a href="/capnproto/next/index.html">Introduction</a></li>
          <li><a href="/capnproto/next/news/">News</a></li>
          <li><a href="/capnproto/next/install.html">Installation</a></li>
          <li><a href="/capnproto/next/language.html">Schema Language</a></li>
          <li><a href="/capnproto/next/encoding.html">Encoding</a></li>
          <li><a href="/capnproto/next/rpc.html">RPC Protocol</a></li>
          <li><a href="/capnproto/next/capnp-tool.html">The <code>capnp</code> Tool</a></li>
          <li><a href="/capnproto/next/cxx.html">C++ Serialization</a></li>
          <li><a href="/capnproto/next/cxxrpc.html">C++ RPC</a></li>
          <li><a href="/capnproto/next/otherlang.html">Other Languages</a></li>
          <li><a href="/capnproto/next/roadmap.html">Road Map</a></li>
          <li><a href="/capnproto/next/faq.html">FAQ</a></li>
        </ul>
      </section>
      <section id="main_content" class="inner">


<div class="hmargin" style="float: right"><a class="groups_link" style="color: #fff"
href="https://groups.google.com/group/capnproto-announce">Stay Updated</a></div>

<h1>News</h1>


<h2><a href="/capnproto/next/./news/2014-06-17-capnproto-flatbuffers-sbe.html">Cap'n Proto, FlatBuffers, and SBE</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">17 Jun 2014</span>
</p>
<p>Yesterday, some engineers at Google released <a href="http://google-opensource.blogspot.com/2014/06/flatbuffers-memory-efficient.html">FlatBuffers</a>, a new serialization protocol and library with similar design principles to Cap’n Proto. Also, a few months back, Real Logic released <a href="http://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html">Simple Binary Encoding</a>, another protocol and library of this nature.</p>

<p>I hesitate to talk much about competitors – other than Protobufs, of course, which I’ll happily bash since it’s largely my own work. As for the rest, attacking humble open source projects makes me feel icky. Normally, I’d rather just wait for a third party to do their own comparison.</p>

<p>However, I haven’t yet seen any really thorough comparisons written by others. Perhaps, this is too niche a field with too few reviewers with enough expertise to really judge. In any case, at the end of the day, users are left in the dark.</p>

<p>So, my goal in this article is to simply surface a bunch of comparison points between these libraries that could help people make decisions. I am trying to be fact-based, but I cannot pretend to be unbiased. My choice of differences to highlight or omit should be considered suspect, but perhaps this will give people a starting point for further investigation.</p>

<h3 id="feature_matrix">Feature Matrix</h3>

<p>The following are a set of considerations I think are importart. See something I missed? Please <a href="mailto:kenton@sandstorm.io">let me know</a> and I’ll add it. (Especially if you are an SBE or FlatBuffers author!)</p>

<p>I will go into more detail on each item below.</p>

<p>Note: For features which are properties of the implementation rather than the protocol or project, unless otherwise stated, I am judging the C++ implementations.</p>
<table class='pass-fail'>
<tr><td>Feature</td><td>Protobuf</td><td>Cap'n Proto</td><td>SBE</td><td>FlatBuffers</td></tr>
<tr><td>Schema evolution</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='pass'>yes</td></tr>
<tr><td>Zero-copy</td><td class='fail'>no</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='pass'>yes</td></tr>
<tr><td>Random-access reads</td><td class='fail'>no</td><td class='pass'>yes</td><td class='fail'>no</td><td class='pass'>yes</td></tr>
<tr><td>Initialiation order</td><td class='pass'>any</td><td class='pass'>any</td><td class='fail'>preorder</td><td class='warn'>bottom-up</td></tr>
<tr><td>Padding takes space on wire?</td><td class='pass'>no</td><td class='pass'>optional</td><td class='fail'>yes</td><td class='fail'>yes</td></tr>
<tr><td>Unset fields take space on wire?</td><td class='pass'>no</td><td class='fail'>yes</td><td class='fail'>yes</td><td class='pass'>no</td></tr>
<tr><td>Pointers take space on wire?</td><td class='pass'>no</td><td class='fail'>yes</td><td class='pass'>no</td><td class='fail'>yes</td></tr>
<tr><td>Unknown field retention</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='fail'>no</td><td class='fail'>no</td></tr>
<tr><td>Object-capability RPC system</td><td class='fail'>no</td><td class='pass'>yes</td><td class='fail'>no</td><td class='fail'>no</td></tr>
<tr><td>Schema language</td><td class='pass'>custom</td><td class='pass'>custom</td><td class='warn'>XML</td><td class='pass'>custom</td></tr>
<tr><td>Safe against malicious input</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='fail'>no</td></tr>
<tr><td>Usable as mutable state</td><td class='pass'>yes</td><td class='fail'>no</td><td class='fail'>no</td><td class='fail'>no</td></tr>
<tr><td>Reflection / generic algorithms</td><td class='pass'>yes</td><td class='pass'>yes</td><td class='fail'>no</td><td class='fail'>no</td></tr>
<tr><td>C++</td><td class='pass'>yes</td><td class='warn'>GCC/Clang</td><td class='pass'>yes</td><td class='pass'>yes</td></tr>
<tr><td>Java</td><td class='pass'>yes</td><td class='warn'>in progress</td><td class='pass'>yes</td><td class='pass'>yes</td></tr>
<tr><td>Python</td><td class='pass'>yes</td><td class='warn'>yes (C ext)</td><td class='fail'>no</td><td class='fail'>no</td></tr>
<tr><td>Other languages</td><td class='pass'>lots!</td><td class='warn'>6+ others</td><td class='warn'>C#</td><td class='fail'>no</td></tr>
<tr><td>Authors' preferred use case</td><td>servers</td><td>sandboxing</td><td>finance</td><td>games</td></tr>
</table>
<p><strong>Schema Evolution</strong></p>

<p>All four protocols allow you to add new fields to a schema over time, without breaking backwards-compatibility. New fields will be ignored by old binaries, and new binaries will fill in a default value when reading old data.</p>

<p><strong>Zero-copy</strong></p>

<p>The central thesis of all three competitors is that data should be structured the same way in-memory and on the wire, thus avoiding costly encode/decode steps.</p>

<p>Protobufs reperesents the old way of thinking.</p>

<p><strong>Random-access reads</strong></p>

<p>Can you traverse the message content in an arbitrary order? Relatedly, can you <code>mmap()</code> in a large (say, 2GB) file, then traverse to and read one particular field without causing the entire file to be paged in from disk?</p>

<p>Protobufs does not allow this because the entire file must be parsed upfront before any of the content can be used. Even with a streaming Protobuf parser (which most libraries don’t provide), you would at least need to parse all data appearing before the bit you want.</p>

<p>SBE does not allow random access because the message tree is written in preorder with no information that would allow one to skip over an entire sub-tree. While the primitive fields within a single object can be accessed in random order, sub-objects must be traversed strictly in preorder.</p>

<p>Cap’n Proto permits random access via the use of pointers, exactly as in-memory data structures in C normally do. These pointers are not quite native pointers – they are relative rather than absolute, to allow the message to be loaded at an arbitrary memory location.</p>

<p>FlatBuffers permits random access by having each record store a table of offsets to all of the field positions.</p>

<p><strong>Initialization order</strong></p>

<p>When building a message, depending on how your code is organized, it may be convenient to have flexibility in the order in which you fill in the data. If that flexibility is missing, you may find you have to do extra bookkeeping to store data off to the side until its time comes to be added to the message.</p>

<p>Protocol Buffers is natually completely flexible in terms of initialization order because the mesasge is being built on the heap. There is no reason to impose restrictions. (Although, the C++ Protobuf library heavily encourages top-down building.)</p>

<p>All the zero-copy systems, though, have to use some form of arena allocation to make sure that the message is built in a contiguous block of memory that can be written out all at once. So, things get more complicated.</p>

<p>SBE specifically requires the message tree to be written in preorder (though, as with reads, the primitive fields within a single object can be initialized in arbitrary order).</p>

<p>FlatBuffers requires that you completely finish one object before you can start building the next, because the size of an object depends on its content so the amount of space needed isn’t known until it is finalized. This also implies that FlatBuffer messages must be built bottom-up, starting from the leaves.</p>

<p>Cap’n Proto imposes no ordering constraints. The size of an object is known when it is allocated, so more objects can be allocated immediately. Messages are normally built top-down, but bottom-up ordering is supported through the “orphans” API.</p>

<p><strong>Padding on wire?</strong></p>

<p>Does the protocol tend to write a lot of zero-valued padding bytes to the wire?</p>

<p>This is a problem with zero-copy protocols: fixed-width integers tend to have a lot of zeros in the high-order bits, and padding sometimes needs to be inserted for alignment. This padding can easily double or triple the size of a message.</p>

<p>Protocol Buffers avoids padding by encoding integers using variable widths, which is only possible given a separate encoding/decoding step.</p>

<p>SBE and FlatBuffers leave the padding in to achieve zero-copy.</p>

<p>Cap’n Proto normally leaves the padding in, but comes with a built-in option to apply a very fast compression algorithm called “packing” which aims only to deflate zeros. This algorithm tends to achieve similar sizes to Protobufs while still being faster (and <em>much</em> faster than general-purpose compression).</p>

<p>Note that Cap’n Proto’s packing algorithm would be appropriate for SBE and FlatBuffers as well. Feel free to steal it. :)</p>

<p><strong>Unset fields on wire?</strong></p>

<p>If a field has not been explicitly assigned a value, will it take any space on the wire?</p>

<p>Protobuf encodes tag-value pairs, so it simply skips pairs that have not been set.</p>

<p>Cap’n Proto and SBE position fields at fixed offsets from the start of the struct. The struct is always allocated large enough for all known fields according to the schema. So, unused fields waste space. (But Cap’n Proto’s optional packing will tend to compress away this space.)</p>

<p>FlatBuffers uses a separate table of offsets (the vtable) to indicate the position of each field, with zero meaning the field isn’t present. So, unset fields take no space on the wire – although they do take space in the vtable. vtables can apparently be shared between instances where the offsets are all the same, amortizing this cost.</p>

<p><strong>Pointers on wire?</strong></p>

<p>Do non-primitive fields require storing a pointer?</p>

<p>Protobufs uses tag-length-value for variable-width fields.</p>

<p>Cap’n Proto uses pointers for variable-width fields, so that the size of the parent object is independent of the size of any children. These pointers take some space on the wire.</p>

<p>SBE requires variable-width fields to be embedded in preorder, which means pointers aren’t necessary.</p>

<p>FlatBuffers also uses pointers, even though most objects are variable-width, possibly because the vtables only store 16-bit offsets, limiting the size of any one object.</p>

<p><strong>Unknown field retention?</strong></p>

<p>Say you read in a message, then copy one sub-object of that message over to a sub-object of a new message, then write out the new message. Say that the copied object was created using a newer version of the schema than you have, and so contains fields you don’t know about. Do those fields get copied over?</p>

<p>This question is extremely important for any kind of service that acts as a proxy or broker, forwarding messages on to others. It can be inconvenient if you have to update these middlemen every time a particular backend protocol changes, when the middlemen often don’t care about the protocol details anyway.</p>

<p>When Protobufs sees an unknown field tag on the wire, it stores the value into the message’s <code>UnknownFieldSet</code>, which can be copied and written back out later.</p>

<p>Cap’n Proto’s wire format was very carefully designed to contain just enough information to make it possible to recursively copy its target from one message to another without knowing the object’s schema. This is why Cap’n Proto pointers contain bits to indicate if they point to a struct or a list and how big it is – seemingly redundant information.</p>

<p>SBE and FlatBuffers do not store any such type information on the wire, and thus it is not possible to copy an object without its schema.</p>

<p><strong>Object-capability RPC system</strong></p>

<p>Cap’n Proto features an object-capability RPC system. While this article is not intended to discuss RPC features, there is an important effect on the serialization format: in an object-capability RPC system, references to remote objects must be a first-class type. That is, a struct field’s type can be “reference to remote object implementing RPC interface Foo”.</p>

<p>Protobufs, SBC, and FlatBuffers do not support this type. Note that it is <em>not</em> sufficient to simply store a string URL, or define some custom struct to represent a reference, because a proper capability-based RPC system must be aware of all references embedded in any message it sends. There are many reasons for this requirement, the most obvious of which is that the system must export the reference or change its permissions to make it available to the receiver.</p>

<p><strong>Schema language</strong></p>

<p>Protobufs, Cap’n Proto, and FlatBuffers have custom, concise schema languages.</p>

<p>SBE uses XML schemas, which are verbose.</p>

<p><strong>Safe against malicious input</strong></p>

<p>Protobufs is carefully designed to be resiliant in the face of all kinds of malicious input, and has undergone a security review by Google’s world-class security team. Not only is the Protobuf implementation secure, but the API is explicitly designed to discourage security mistakes in application code. It is considered a security flaw in Protobufs if the interface makes client apps likely to write insecure code.</p>

<p>Cap’n Proto inherits Protocol Buffers’ security stance, and is believed to be similarly secure. However, it has not yet undergone security review.</p>

<p>SBE’s C++ library does bounds checking as of the resolution of <a href="https://github.com/real-logic/simple-binary-encoding/issues/130">this bug</a>.</p>

<p>FlatBuffers does no bounds checking. When reading a message, you start by giving the library a bare pointer to the start of the message, with no size. FlatBuffers appears to be intended for use as a format for static, trusted data files, not network messages.</p>

<p><strong>Usable as mutable state</strong></p>

<p>Protobuf generated classes have often been (ab)used as a convenient way to store an application’s mutable internal state. There’s mostly no problem with modifying a message gradually over time and then serializing it when needed.</p>

<p>This usage pattern does not work well with any zero-copy serialization format because these formats must use arena-style allocation to make sure the message is built in contiguous memory. Arena allocation has the property that you cannot free any object unless you free the entire arena. Therefore, when objects are discarded, the memory ends up leaked until the message as a whole is destoryed. A long-lived message that is modified many times will thus leak memory.</p>

<p><strong>Reflection / generic algorithms</strong></p>

<p>Protobufs provides a “reflection” interface which allows dynamically iterating over all the fields of a message, getting their names and other metadata, and reading and modifying their values in a particular instance. Cap’n Proto also supports this, calling it the “Dynamic API”. SBE and FlatBuffers provide no such API.</p>

<p>Having a reflection/dynamic API opens up a wide range of use cases. You can write reflection-based code which converts the message to/from another format such as JSON – useful not just for interoperability, but for debugging, because it is human-readable. Another popular use of reflection is writing bindings for scripting languages. For example, Python’s Cap’n Proto implementation is simply a wrapper around the C++ dynamic API.</p>

<p>The down side of reflection is that it is generally very slow (compared to generated code) and can lead to code bloat. Cap’n Proto is designed such that the reflection APIs need not be linked into your app if you do not use them, although this requires statically linking the library to get the benefit.</p>

<p><strong>Platform Support</strong></p>

<p>A really huge weakness of Cap’n Proto today is that it doesn’t compile in Visual Studio, and therefore effectively doesn’t support Windows (unless you count Cygwin, but most people don’t).</p>

<p>The problem initially was that Cap’n Proto makes liberal use of C++11 features, and MSVC has lagged behind in implementing them. We conidered, but balked at, forking and backporting. It looks like <a href="http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx">VS14 CTP1</a> may finally be far enough to make a port practical, so now it’s just a matter of finding the time. But that’s a new problem: all my time is currently consumed by <a href="https://sandstorm.io">Sandstorm.io</a>, and while it is a major use of Cap’n Proto and will thus drive further development, it is entirely Linux-based, making it hard for me to justify spending my time on Windows support. What we need is a volunteer!</p>

<h3 id="benchmarks">Benchmarks?</h3>

<p>I do not provide benchmarks. I did not provide them when I launched Protobufs, nor when I launched Cap’n Proto, even though I had some with nice numbers. And I don’t see any reason to start now.</p>

<p>Why? Because they would tell you nothing. I could easily construct a benchmark to make any given library “win”, by exploiting the relative tradeoffs each one makes. I can even construct one where Protobufs – supposedly infinitely slower than the others – wins.</p>

<p>The fact of the matter is that the relative performance of these libraries depends deeply on the use case. To know which one will be fastest for <em>your</em> project, you really need to benchmark them in <em>your</em> project, end-to-end. No contrived benchmark will give you the answer.</p>

<p>With that said, my intuition is that SBE will probably edge Cap’n Proto and FlatBuffers on performance in the average case, due to its decision to forgo support for random access. Between Cap’n Proto and FlatBuffers, it’s harder to say. FlatBuffers’ vtable approach seems like it would make access more expensive for primitive fields but perhaps cheaper for aggregates. FlatBuffers also appears to do a lot of bookkeeping at encoding time which could get costly, but I don’t know how costly.</p>

<p>For most people, the performance difference is probably small enough that qualitative (feature) differences in the libraries matter more.</p>

<h2><a href="/capnproto/next/./news/2014-03-11-capnproto-0.4.1-bugfixes.html">Cap'n Proto 0.4.1: Bugfix Release</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">11 Mar 2014</span>
</p>
<p>Today I’m releasing <a href="https://capnproto.org/capnproto-c++-0.4.1.tar.gz">version 0.4.1 of Cap’n Proto</a>. As hinted by the version number, this is a bugfix and tweak release, with no big new features.</p>

<p>You may be wondering: If there are no big new features, what has been happening over the last three months? Most of my time lately has been spent laying the groundwork for an interesting project built on Cap’n Proto which should launch by the end of this month. Stay tuned! And don’t worry – this new project is going to need many of the upcoming features on <a href="/capnproto/next/roadmap.html">the roadmap</a>, so work on version 0.5 will be proceeding soon.</p>

<p>In the meantime, though, there have been some major updates from the community:</p>

<ul>
<li>The folks at <a href="https://www.cloudflare.com/">CloudFlare</a> have produced a <a href="https://github.com/cloudflare/lua-capnproto">Lua port</a> which they are <a href="http://blog.cloudflare.com/introducing-lua-capnproto-better-serialization-in-lua">using successfully in production</a> along with the existing <a href="https://github.com/jmckaskill/go-capnproto">Go port</a>.</li>

<li><a href="https://github.com/dwrensha/capnproto-rust">The Rust port of Cap’n Proto</a> now has preliminary RPC support, making it the third language to support Cap’n Proto RPC (after C++ and Python), and the second language to implement it from the ground up (Python just wraps the C++ implementation). Check out author <a href="https://github.com/dwrensha">David Renshaw</a>’s <a href="https://air.mozilla.org/rust-meetup-february-2014/">talk at Mozilla</a>.</li>

<li>A <a href="https://github.com/jscheid/capnproto-js">Javascript port</a> has appeared, but it needs help to keep going!</li>
</ul>

<h2><a href="/capnproto/next/./news/2013-12-13-promise-pipelining-capnproto-vs-ice.html">Promise Pipelining and Dependent Calls: Cap'n Proto vs. Thrift vs. Ice</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">13 Dec 2013</span>
</p>
<p>So, I totally botched the 0.4 release announcement yesterday. I was excited about promise pipelining, but I wasn’t sure how to describe it in headline form. I decided to be a bit silly and call it “time travel”, tongue-in-cheek. My hope was that people would then be curious, read the docs, find out that this is actually a really cool feature, and start doing stuff with it.</p>

<p>Unfortunately, <a href="2013-12-12-capnproto-0.4-time-travel.html">my post</a> only contained a link to the full explanation and then confusingly followed the “time travel” section with a separate section describing the fact that I had implemented a promise API in C++. Half the readers clicked through to the documentation and understood. The other half thought I was claiming that promises alone constituted “time travel”, and thought I was ridiculously over-hyping an already-well-known technique. My HN post was subsequently flagged into oblivion.</p>

<p>Let me be clear:</p>

<p><strong>Promises alone are <em>not</em> what I meant by “time travel”!</strong></p>

<p><img src='/capnproto/next/images/capnp-vs-thrift-vs-ice.png' style='width:350px; height:275px; float: right;' /></p>

<p>So what did I mean? Perhaps <a href="https://github.com/kentonv/capnp-vs-ice">this benchmark</a> will make things clearer. Here, I’ve defined a server that exports a simple four-function calculator interface, with <code>add()</code>, <code>sub()</code>, <code>mult()</code>, and <code>div()</code> calls, each taking two integers and\ returning a result.</p>

<p>You are probably already thinking: That’s a ridiculously bad way to define an RPC interface! You want to have <em>one</em> method <code>eval()</code> that takes an expression tree (or graph, even), otherwise you will have ridiculous latency. But this is exactly the point. <strong>With promise pipelining, simple, composable methods work fine.</strong></p>

<p>To prove the point, I’ve implemented servers in Cap’n Proto, <a href="http://thrift.apache.org/">Apache Thrift</a>, and <a href="http://www.zeroc.com/">ZeroC Ice</a>. I then implemented clients against each one, where the client attempts to evaluate the expression:</p>

<pre><code>((5 * 2) + ((7 - 3) * 10)) / (6 - 4)</code></pre>

<p>All three frameworks support asynchronous calls with a promise/future-like interface, and all of my clients use these interfaces to parallelize calls. However, notice that even with parallelization, it takes four steps to compute the result:</p>

<pre><code># Even with parallelization, this takes four steps!
((5 * 2) + ((7 - 3) * 10)) / (6 - 4)
  (10    + (   4    * 10)) /    2      # 1
  (10    +         40)     /    2      # 2
        50                 /    2      # 3
                          25           # 4</code></pre>

<p>As such, the Thrift and Ice clients take four network round trips. Cap’n Proto, however, takes only one.</p>

<p>Cap’n Proto, you see, sends all six calls from the client to the server at one time. For the latter calls, it simply tells the server to substitute the former calls’ results into the new requests, once those dependency calls finish. Typical RPC systems can only send three calls to start, then must wait for some to finish before it can continue with the remaining calls. Over a high-latency connection, this means they take 4x longer than Cap’n Proto to do their work in this test.</p>

<p>So, does this matter outside of a contrived example case? Yes, it does, because it allows you to write cleaner interfaces with simple, composable methods, rather than monster do-everything-at-once methods. The four-method calculator interface is much simpler than one involving sending an expression graph to the server in one batch. Moreover, pipelining allows you to define object-oriented interfaces where you might otherwise be tempted to settle for singletons. See <a href="/capnproto/next/rpc.html#introduction">my extended argument</a> (this is what I was trying to get people to click on yesterday :) ).</p>

<p>Hopefully now it is clearer what I was trying to illustrate with this diagram, and what I meant by “time travel”!</p>

<p><img src='/capnproto/next/images/time-travel.png' style='max-width:639px' /></p>

<h2><a href="/capnproto/next/./news/2013-12-12-capnproto-0.4-time-travel.html">Cap'n Proto v0.4: Time Traveling RPC</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">12 Dec 2013</span>
</p>
<p>Well, <a href="http://en.wikipedia.org/wiki/Hofstadter's_law">Hofstadter</a> kicked in and this release took way too long. But, after three long months, I’m happy to announce:</p>

<h3 id="timetraveling_rpc_promise_pipelining">Time-Traveling RPC <em>(Promise Pipelining)</em></h3>

<p><img src='/capnproto/next/images/time-travel.png' style='max-width:639px' /></p>

<p>v0.4 finally introduces the long-promised <a href="/capnproto/next/rpc.html">RPC system</a>. Traditionally, RPC is plagued by the fact that networks have latency, and pretending that latency doesn’t exist by hiding it behind what looks like a normal function call only makes the problem worse. Cap’n Proto has a simple solution to this problem: send call results <em>back in time</em>, so they arrive at the client at the point in time when the call was originally made!</p>

<p>Curious how Cap’n Proto bypasses the laws of physics? <a href="/capnproto/next/rpc.html">Check out the docs!</a></p>

<p><em>UPDATE: There has been some confusion about what I’m claiming. I am NOT saying that using promises alone (i.e. being asynchronous) constitutes “time travel”. Cap’n Proto implements a technique called Promise Pipelining which allows a new request to be formed based on the content of a previous result (in part or in whole) before that previous result is returned. Notice in the diagram that the result of foo() is being passed to bar(). Please <a href="/capnproto/next/rpc.html">see the docs</a> or <a href="https://github.com/kentonv/capnproto/blob/master/c++/samples">check out the calculator example</a> for more.</em></p>

<h3 id="promises_in_c">Promises in C++</h3>

<p><em>UPDATE: More confusion. This section is <strong>not</strong> about pipelining (“time travel”). This section is just talking about implementing a promise API in C++. Pipelining is another feature on top of that. Please <a href="/capnproto/next/rpc.html">see the RPC page</a> if you want to know more about pipelining.</em></p>

<p>If you do a lot of serious Javascript programming, you’ve probably heard of <a href="http://promisesaplus.com/">Promises/A+</a> and similar proposals. Cap’n Proto RPC introduces a similar construct in C++. In fact, the API is nearly identical, and its semantics are nearly identical. Compare with <a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">Domenic Denicola’s Javascript example</a>:</p>
<div class='highlight'><pre><code class='c++'><span class='c1'>// C++ version of Domenic&#39;s Javascript promises example.</span>
<span class='n'>getTweetsFor</span><span class='p'>(</span><span class='s'>&quot;domenic&quot;</span><span class='p'>)</span> <span class='c1'>// returns a promise</span>
  <span class='p'>.</span><span class='n'>then</span><span class='p'>([](</span><span class='n'>vector</span><span class='o'>&lt;</span><span class='n'>Tweet</span><span class='o'>&gt;</span> <span class='n'>tweets</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>auto</span> <span class='n'>shortUrls</span> <span class='o'>=</span> <span class='n'>parseTweetsForUrls</span><span class='p'>(</span><span class='n'>tweets</span><span class='p'>);</span>
    <span class='k'>auto</span> <span class='n'>mostRecentShortUrl</span> <span class='o'>=</span> <span class='n'>shortUrls</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>];</span>
    <span class='c1'>// expandUrlUsingTwitterApi returns a promise</span>
    <span class='k'>return</span> <span class='nf'>expandUrlUsingTwitterApi</span><span class='p'>(</span><span class='n'>mostRecentShortUrl</span><span class='p'>);</span>
  <span class='p'>})</span>
  <span class='p'>.</span><span class='n'>then</span><span class='p'>(</span><span class='n'>httpGet</span><span class='p'>)</span> <span class='c1'>// promise-returning function</span>
  <span class='p'>.</span><span class='n'>then</span><span class='p'>(</span>
    <span class='p'>[](</span><span class='n'>string</span> <span class='n'>responseBody</span><span class='p'>)</span> <span class='p'>{</span>
      <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;Most recent link text:&quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>responseBody</span> <span class='o'>&lt;&lt;</span> <span class='n'>endl</span><span class='p'>;</span>
    <span class='p'>},</span>
    <span class='p'>[](</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>Exception</span><span class='o'>&amp;&amp;</span> <span class='n'>error</span><span class='p'>)</span> <span class='p'>{</span>
      <span class='n'>cerr</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;Error with the twitterverse:&quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>error</span> <span class='o'>&lt;&lt;</span> <span class='n'>endl</span><span class='p'>;</span>
    <span class='p'>}</span>
  <span class='p'>);</span>
</code></pre></div>
<p>This is C++, but it is no more lines – nor otherwise more complex – than the equivalent Javascript. We’re doing several I/O operations, we’re doing them asynchronously, and we don’t have a huge unreadable mess of callback functions. Promises are based on event loop concurrency, which means you can perform concurrent operations with shared state without worrying about mutex locking – i.e., the Javascript model. (Of course, if you really want threads, you can run multiple event loops in multiple threads and make inter-thread RPC calls between them.)</p>

<p><a href="/capnproto/next/cxxrpc.html#kj_concurrency_framework">More on C++ promises.</a></p>

<h3 id="python_too">Python too</h3>

<p><a href="https://github.com/jparyani">Jason</a> has been diligently keeping his <a href="http://jparyani.github.io/pycapnp/">Python bindings</a> up to date, so you can already use RPC there as well. The Python interactive interpreter makes a great debugging tool for calling C++ servers.</p>

<h3 id="up_next">Up Next</h3>

<p>Cap’n Proto is far from done, but working on it in a bubble will not produce ideal results. Starting after the holidays, I will be refocusing some of my time into an adjacent project which will be a heavy user of Cap’n Proto. I hope this experience will help me discover first hand the pain points in the current interface and keep development going in the right direction.</p>

<p>This does, however, mean that core Cap’n Proto development will slow somewhat (unless contributors pick up the slack! ;) ). I am extremely excited about this next project, though, and I think you will be too. Stay tuned!</p>

<h2><a href="/capnproto/next/./news/2013-09-04-capnproto-0.3-python-tools-features.html">Cap'n Proto v0.3: Python, tools, new features</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">04 Sep 2013</span>
</p>
<p>The first release of Cap’n Proto came three months after the project was announced. The second release came six weeks after that. And the third release is three weeks later. If the pattern holds, there will be an infinite number of releases before the end of this month.</p>

<p>Version 0.3 is not a paradigm-shifting release, but rather a slew of new features largely made possible by building on the rewritten compiler from the last release. Let’s go through the list</p>

<h3 id="python_support">Python Support!</h3>

<p>Thanks to the tireless efforts of contributor <a href="https://github.com/jparyani">Jason Paryani</a>, I can now comfortably claim that Cap’n Proto supports multiple languages. <a href="http://jparyani.github.io/pycapnp/">His Python implementation</a> wraps the C++ library and exposes most of its features in a nice, easy-to-use way.</p>

<p>And I have to say, it’s <em>way</em> better than the old Python Protobuf implementation that I helped put together at Google. Here’s why:</p>

<ul>
<li>Jason’s implementation parses Cap’n Proto schema files at runtime. There is no need to run a compiler to generate code every time you update your schema, as with protobufs. So, you get to use Python the way Python was intended to be used. In fact, he’s hooked into the Python import mechanism, so you can basically import a <code>.capnp</code> schema file as if it were a <code>.py</code> module. It’s even convenient to load schema files and play with Cap’n Proto messages from the interactive interpreter prompt.</li>

<li>It’s <em>fast</em>. Whereas the Python Protobuf implementation – which we made the mistake of implementing in pure-Python – is <em>slow</em>. And while technically there is an experimental C-extension-based Python Protobuf implementation (which isn’t enabled by default due to various obscure problems), Jason’s Cap’n Proto implementation is faster than that, too.</li>
</ul>

<p>Go <a href="http://jparyani.github.io/pycapnp/">check it out</a>!</p>

<p>By the way, there is also a budding <a href="http://ecapnp.astekk.se/">Erlang implementation</a> (by Andreas Stenius), and work continues on <a href="https://github.com/dwrensha/capnproto-rust">Rust</a> (David Renshaw) and <a href="https://github.com/cstrahan/capnp-ruby">Ruby</a> (Charles Strahan) implementations.</p>

<h3 id="tools_capn_proto_on_the_command_line">Tools: Cap’n Proto on the Command Line</h3>

<p>The <code>capnp</code> command-line tool previously served mostly to generate code, via the <code>capnp compile</code> command. It now additionally supports converting encoded Cap’n Proto messages to a human-readable text format via <code>capnp decode</code>, and converting that format back to binary with <code>capnp encode</code>. These tools are, of course, critical for debugging.</p>

<p>You can also use the new <code>capnp eval</code> command to do something interesting: given a schema file and the name of a constant defined therein, it will print out the value of that constant, or optionally encode it to binary. This is more interesting than it sounds because the schema language supports variable substitution in the definitions of these constants. This means you can build a large structure by importing smaller bits from many different files. This may make it convenient to use Cap’n Proto schemas as a config format: define your service configuration as a constant in a schema file, importing bits specific to each client from other files that those clients submit to you. Use <code>capnp eval</code> to “compile” the whole thing to binary for deployment. (This has always been a common use case for Protobuf text format, which doesn’t even support variable substitution or imports.)</p>

<p>Anyway, check out the <a href="/capnproto/next/capnp-tool.html">full documentation</a> for more.</p>

<h3 id="new_features">New Features</h3>

<p>The core product has been updated as well:</p>

<ul>
<li>Support for unnamed <a href="/capnproto/next/language.html#unions">unions</a> reduces the need for noise-words, improving code readability. Additionally, the syntax for unions has been simplified by removing the unnecessary ordinal number.</li>

<li><a href="/capnproto/next/language.html#groups">Groups</a> pair nicely with unions.</li>

<li><a href="/capnproto/next/language.html#constants">Constants</a> are now <a href="/capnproto/next/cxx.html#constants">implemented in C++</a>. Additionally, they can now be defined in terms of other constants (variable substitution), as described earlier.</li>

<li>The schema API and <code>schema.capnp</code> have been radically refactored, in particular to take advantage of the new union and group features, making the code more readable.</li>

<li>More and better tests, bug fixes, etc.</li>
</ul>

<h3 id="users">Users!</h3>

<p>Some news originating outside of the project itself:</p>

<ul>
<li><a href="http://www.debian.org/releases/sid/">Debian Unstable (sid)</a> now features <a href="http://packages.debian.org/sid/capnproto">a Cap’n Proto package</a>, thanks to <a href="https://github.com/thomaslee">Tom Lee</a>. Of course, since package updates take some time, this package is still v0.2.1 as of this writing, but it will be updated to v0.3 soon enough.</li>

<li>Popular OSX-based text editor <a href="http://macromates.com/">TextMate</a> now <a href="https://github.com/textmate/textmate/commit/5c02b4ff5cc0c7c319d3d4f127c8ee19b81f80b7">uses Cap’n Proto internally</a>, and the developer’s feedback lead directly to several usability improvements included in this release.</li>

<li>Many people using Cap’n Proto <em>haven’t bothered to tell us about it</em>! Please, if you use it, <a href="https://groups.google.com/group/capnproto">let us know</a> about your experience, both what you like and especially what you don’t like. This is the critical time where the system is usable but can still be changed if it’s not right, so your feedback is critical to our long-term success.</li>

<li>I have revenue! A whopping <a href="https://www.gittip.com/kentonv/">$1.25 per week</a>! &gt;_&gt; It’s totally worth it; I love this project. (But thanks for the tips!)</li>
</ul>

<h2><a href="/capnproto/next/./news/2013-08-19-capnproto-0.2.1.html">Cap'n Proto v0.2.1: Minor bug fixes</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">19 Aug 2013</span>
</p>
<p>Cap’n Proto was just bumped to v0.2.1. This release contains a couple bug fixes, including a work-around for <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58192">a GCC bug</a>. If you were observing any odd memory corruption or crashes in 0.2.0 – especially if you are compiling with GCC with optimization enabled but without <code>-DNDEBUG</code> – you should upgrade.</p>

<h2><a href="/capnproto/next/./news/2013-08-12-capnproto-0.2-no-more-haskell.html">Cap'n Proto v0.2: Compiler rewritten Haskell -> C++</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">12 Aug 2013</span>
</p>
<p>Today I am releasing version 0.2 of Cap’n Proto. The most notable change: the compiler / code generator, which was previously written in Haskell, has been rewritten in C++11. There are a few other changes as well, but before I talk about those, let me try to calm the angry mob that is not doubt reaching for their pitchforks as we speak. There are a few reasons for this change, some practical, some ideological. I’ll start with the practical.</p>

<p><strong>The practical: Supporting dynamic languages</strong></p>

<p>Say you are trying to implement Cap’n Proto in an interpreted language like Python. One of the big draws of such a language is that you can edit your code and then run it without an intervening compile step, allowing you to iterate faster. But if the Python Cap’n Proto implementation worked like the C++ one (or like Protobufs), you lose some of that: whenever you change your Cap’n Proto schema files, you must run a command to regenerate the Python code from them. That sucks.</p>

<p>What you really want to do is parse the schemas at start-up – the same time that the Python code itself is parsed. But writing a proper schema parser is harder than it looks; you really should reuse the existing implementation. If it is written in Haskell, that’s going to be problematic. You either need to invoke the schema parser as a sub-process or you need to call Haskell code from Python via an FFI. Either approach is going to be a huge hack with lots of problems, not the least of which is having a runtime dependency on an entire platform that your end users may not otherwise want.</p>

<p>But with the schema parser written in C++, things become much simpler. Python code calls into C/C++ all the time. Everyone already has the necessary libraries installed. There’s no need to generate code, even; the parsed schema can be fed into the Cap’n Proto C++ runtime’s dynamic API, and Python bindings can trivially be implemented on top of that in just a few hundred lines of code. Everyone wins.</p>

<p><strong>The ideological: I’m an object-oriented programmer</strong></p>

<p>I really wanted to like Haskell. I used to be a strong proponent of functional programming, and I actually once wrote a complete web server and CMS in a purely-functional toy language of my own creation. I love strong static typing, and I find a lot of the constructs in Haskell really powerful and beautiful. Even monads. <em>Especially</em> monads.</p>

<p>But when it comes down to it, I am an object-oriented programmer, and Haskell is not an object-oriented language. Yes, you can do object-oriented style if you want to, just like you can do objects in C. But it’s just too painful. I want to write <code>object.methodName</code>, not <code>ModuleName.objectTypeMethodName object</code>. I want to be able to write lots of small classes that encapsulate complex functionality in simple interfaces – <em>without</em> having to place each one in a whole separate module and ending up with thousands of source files. I want to be able to build a list of objects of varying types that implement the same interface without having to re-invent virtual tables every time I do it (type classes don’t quite solve the problem).</p>

<p>And as it turns out, even aside from the lack of object-orientation, I don’t acutally like functional programming as much as I thought. Yes, writing my parser was super-easy (my first commit message was ”<a href="https://github.com/kentonv/capnproto/commit/6bb49ca775501a9b2c7306992fd0de53c5ee4e95">Day 1: Learn Haskell, write a parser</a>”). But everything beyond that seemed to require increasing amounts of brain bending. For instance, to actually encode a Cap’n Proto message, I couldn’t just allocate a buffer of zeros and then go through each field and set its value. Instead, I had to compute all the field values first, sort them by position, then concatenate the results.</p>

<p>Of course, I’m sure it’s the case that if I spent years writing Haskell code, I’d eventually become as proficient with it as I am with C++. Perhaps I could un-learn object-oriented style and learn something else that works just as well or better. Basically, though, I decided that this was going to take a lot longer than it at first appeared, and that this wasn’t a good use of my limited resources. So, I’m cutting my losses.</p>

<p>I still think Haskell is a very interesting language, and if works for you, by all means, use it. I would love to see someone write at actual Cap’n Proto runtime implementation in Haskell. But the compiler is now C++.</p>

<p><strong>Parser Combinators in C++</strong></p>

<p>A side effect (so to speak) of the compiler rewrite is that Cap’n Proto’s companion utility library, KJ, now includes a parser combinator framework based on C++11 templates and lambdas. Here’s a sample:</p>
<div class='highlight'><pre><code class='c++'><span class='c1'>// Construct a parser that parses a number.</span>
<span class='k'>auto</span> <span class='n'>number</span> <span class='o'>=</span> <span class='n'>transform</span><span class='p'>(</span>
    <span class='n'>sequence</span><span class='p'>(</span>
        <span class='n'>oneOrMore</span><span class='p'>(</span><span class='n'>charRange</span><span class='p'>(</span><span class='sc'>&#39;0&#39;</span><span class='p'>,</span> <span class='sc'>&#39;9&#39;</span><span class='p'>)),</span>
        <span class='n'>optional</span><span class='p'>(</span><span class='n'>sequence</span><span class='p'>(</span>
            <span class='n'>exactChar</span><span class='o'>&lt;</span><span class='sc'>&#39;.&#39;</span><span class='o'>&gt;</span><span class='p'>(),</span>
            <span class='n'>many</span><span class='p'>(</span><span class='n'>charRange</span><span class='p'>(</span><span class='sc'>&#39;0&#39;</span><span class='p'>,</span> <span class='sc'>&#39;9&#39;</span><span class='p'>))))),</span>
    <span class='p'>[](</span><span class='n'>Array</span><span class='o'>&lt;</span><span class='kt'>char</span><span class='o'>&gt;</span> <span class='n'>whole</span><span class='p'>,</span> <span class='n'>Maybe</span><span class='o'>&lt;</span><span class='n'>Array</span><span class='o'>&lt;</span><span class='kt'>char</span><span class='o'>&gt;&gt;</span> <span class='n'>maybeFraction</span><span class='p'>)</span>
        <span class='o'>-&gt;</span> <span class='n'>Number</span><span class='o'>*</span> <span class='p'>{</span>
      <span class='n'>KJ_IF_MAYBE</span><span class='p'>(</span><span class='n'>fraction</span><span class='p'>,</span> <span class='n'>maybeFraction</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>return</span> <span class='k'>new</span> <span class='n'>RealNumber</span><span class='p'>(</span><span class='n'>whole</span><span class='p'>,</span> <span class='o'>*</span><span class='n'>fraction</span><span class='p'>);</span>
      <span class='p'>}</span> <span class='k'>else</span> <span class='p'>{</span>
        <span class='k'>return</span> <span class='k'>new</span> <span class='n'>WholeNumber</span><span class='p'>(</span><span class='n'>whole</span><span class='p'>);</span>
      <span class='p'>}</span>
    <span class='p'>});</span>
</code></pre></div>
<p>An interesting fact about the above code is that constructing the parser itself does not allocate anything on the heap. The variable <code>number</code> in this case ends up being one 96-byte flat object, most of which is composed of tables for character matching. The whole thing could even be declared <code>constexpr</code>… if the C++ standard allowed empty-capture lambdas to be <code>constexpr</code>, which unfortunately it doesn’t (yet).</p>

<p>Unfortunately, KJ is largely undocumented at the moment, since people who just want to use Cap’n Proto generally don’t need to know about it.</p>

<p><strong>Other New Features</strong></p>

<p>There are a couple other notable changes in this release, aside from the compiler:</p>

<ul>
<li>
<p>Cygwin has been added as a supported platform, meaning you can now use Cap’n Proto on Windows. I am considering supporting MinGW as well. Unfortunately, MSVC is unlikely to be supported any time soon as its C++11 support is <a href="http://blogs.msdn.com/b/somasegar/archive/2013/06/28/cpp-conformance-roadmap.aspx">woefully lacking</a>.</p>
</li>

<li>
<p>The new compiler binary – now called <code>capnp</code> rather than <code>capnpc</code> – is more of a multi-tool. It includes the ability to decode binary messages to text as a debugging aid. Type <code>capnp help decode</code> for more information.</p>
</li>

<li>
<p>The new <a href="/capnproto/next//cxx.html#orphans">Orphan</a> class lets you detach objects from a message tree and re-attach them elsewhere.</p>
</li>

<li>
<p>Various contributors have declared their intentions to implement <a href="https://github.com/cstrahan/capnp-ruby">Ruby</a>, <a href="https://github.com/dwrensha/capnproto-rust">Rust</a>, C#, Java, Erlang, and Delphi bindings. These are still works in progress, but exciting nonetheless!</p>
</li>
</ul>

<p><strong>Backwards-compatibility Note</strong></p>

<p>Cap’n Proto v0.2 contains an obscure wire format incompatibility with v0.1. If you are using unions containing multiple primitive-type fields of varying sizes, it’s possible that the new compiler will position those fields differently. A work-around to get back to the old layout exists; if you believe you could be affected, please <a href="mailto:temporal@gmail.com">send me</a> your schema and I’ll tell you what to do. <a href="https://groups.google.com/d/msg/capnproto/NIYbD0haP38/pH5LildInwIJ">Gory details.</a></p>

<p><strong>Road Map</strong></p>

<p>v0.3 will come in a couple weeks and will include several new features and clean-ups that can now be implemented more easily given the new compiler. This will also hopefully be the first release that officially supports a language other than C++.</p>

<p>The following release, v0.4, will hopefully be the first release implementing RPC.</p>

<p><em>PS. If you are wondering, compared to the Haskell version, the new compiler is about 50% more lines of code and about 4x faster. The speed increase should be taken with a grain of salt, though, as my Haskell code did all kinds of horribly slow things. The code size is, I think, not bad, considering that Haskell specializes in concision – but, again, I’m sure a Haskell expert could have written shorter code.</em></p>

<h2><a href="/capnproto/next/./news/2013-06-27-capn-proto-beta-release.html">Cap'n Proto Beta Release</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">27 Jun 2013</span>
</p>
<p>It’s been nearly three months since Cap’n Proto was originally announced, and by now you’re probably wondering what I’ve been up to. The answer is basically <a href="https://github.com/kentonv/capnproto/commits/master">non-stop coding</a>. Features were implemented, code was refactored, tests were written, and now Cap’n Proto is beginning to resemble something like a real product. But as is so often the case with me, I’ve been so engrossed in coding that I forgot to post updates!</p>

<p>Well, that changes today, with the first official release of Cap’n Proto, v0.1. While not yet “done”, this release should be usable for Real Work. Feature-wise, for C++, the library is roughly on par with <a href="http://protobuf.googlecode.com">Google’s Protocol Buffers</a> (which, as you know, I used to maintain). Features include:</p>

<ul>
<li>Types: numbers, bytes, text, enums, lists, structs, and unions.</li>

<li>Code generation from schema definition files.</li>

<li>Reading from and writing to file descriptors (or other streams).</li>

<li>Text-format output (e.g. for debugging).</li>

<li>Reflection, for writing generic code that dynamically walks over message contents.</li>

<li>Dynamic schema loading (to manipulate types not known at compile time).</li>

<li>Code generator plugins for extending the compiler to support new languages.</li>

<li>Tested on Linux and Mac OSX with GCC and Clang.</li>
</ul>

<p>Notably missing from this list is RPC (something Protocol Buffers never provided either). The RPC system is still in the design phase, but will be implemented over the coming weeks.</p>

<p>Also missing is support for languages other than C++. However, I’m happy to report that a number of awesome contributors have stepped up and are working on <a href="/capnproto/next/otherlang.html">implementations in C, Go, Python</a>, and a few others not yet announced. None of these are “ready” just yet, but watch this space. (Would you like to work on an implementation in your favorite language? <a href="https://groups.google.com/group/capnproto">Let us know!</a>)</p>

<p>Going forward, Cap’n Proto releases will occur more frequently, perhaps every 2-4 weeks. Consider <a href="https://groups.google.com/group/capnproto-announce">signing up for release announcements</a>.</p>

<p>In any case, go <a href="/capnproto/next/install.html">download the release</a> and <a href="https://groups.google.com/group/capnproto">tell us your thoughts</a>.</p>

<h2><a href="/capnproto/next/./news/2013-04-01-announcing-capn-proto.html">Announcing Cap'n Proto</a></h2>
<p class="author">
  <a href="https://github.com/kentonv">kentonv</a>
  
  <span class="gplus-followbutton"><span class="g-follow" data-annotation="none" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
  <a href="https://www.gittip.com/kentonv/"><img class="gittip" src="/capnproto/next/images/gittip.png" alt="Gittip"></a>
  
  on <span class="date">01 Apr 2013</span>
</p>
<p><img src='/capnproto/next/images/infinity-times-faster.png' style='width:334px; height:306px; float: right;' /></p>

<p>So, uh… I have a confession to make.</p>

<p>I may have rewritten Protocol Buffers.</p>

<p>Again.</p>

<p><a href="http://kentonv.github.com/capnproto">And it’s infinity times faster.</a></p>


<script type="text/javascript">setupSidebar()</script>
        <div style="clear: both;"></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cap'n Proto maintained by <a href="https://github.com/kentonv">kentonv</a>
          <span class="gplus-followbutton"><span class="g-follow" data-annotation="bubble" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
          <a href="https://www.gittip.com/kentonv/"><img class="gittip15" src="/capnproto/next/images/gittip15.png" alt="Gittip"></a></p>
        <p>Design by <a href="http://www.starfruit-cafe.net/blog">sailorhg</a> ∙ Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    <!-- Google+ follow button. -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>

    <!-- Google Analytics. -->
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-39711112-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>
  </body>
</html>

