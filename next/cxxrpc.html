<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=480">

    <link rel="stylesheet" type="text/css" media="screen" href="/capnproto/next/stylesheets/stylesheet.css">

    <title>Cap'n Proto: C++ RPC</title>

    <script type="text/javascript" src="/capnproto/next/javascripts/main.js"></script>
  </head>

  <body class="desktop">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
        <img src="/capnproto/next/images/logo.png">
        <div id="infinitely_faster">
          <img src="/capnproto/next/images/infinitely_faster.png">
        </div>
      </header>
      <a id="discuss_banner" href="https://groups.google.com/group/capnproto">Discuss on Groups</a>
      <a id="forkme_banner" href="https://github.com/kentonv/capnproto">View on GitHub</a>
    </div>

    
    <div id="next_banner">
      <h1>PREVIEW</h1>
      <p>You are looking at the site as it will appear after the next release.  This is a draft
         version that may be incomplete, buggy, or not yet applicable.  To look at the current
         site, <a href="../">click here</a>.
    </div>
    

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">

      <section id="menu">
        <ul>
          <li><a href="/capnproto/next/index.html">Introduction</a></li>
          <li><a href="/capnproto/next/news/">News</a></li>
          <li><a href="/capnproto/next/install.html">Installation</a></li>
          <li><a href="/capnproto/next/language.html">Schema Language</a></li>
          <li><a href="/capnproto/next/encoding.html">Encoding</a></li>
          <li><a href="/capnproto/next/rpc.html">RPC Protocol</a></li>
          <li><a href="/capnproto/next/capnp-tool.html">The <code>capnp</code> Tool</a></li>
          <li><a href="/capnproto/next/cxx.html">C++ Serialization</a></li>
          <li><a href="/capnproto/next/cxxrpc.html">C++ RPC</a></li>
          <li><a href="/capnproto/next/otherlang.html">Other Languages</a></li>
          <li><a href="/capnproto/next/roadmap.html">Road Map</a></li>
          <li><a href="/capnproto/next/faq.html">FAQ</a></li>
        </ul>
      </section>
      <section id="main_content" class="inner">

<h1 id="c_rpc">C++ RPC</h1>

<p>The Cap’n Proto C++ RPC layer sits on top of the <a href="cxx.html">serialization layer</a> and implements the <a href="rpc.html">RPC protocol</a>.</p>

<h2 id="current_status">Current Status</h2>

<p>As of version 0.4, Cap’n Proto’s C++ RPC implementation is a <a href="rpc.html#protocol_features">Level 1</a> implementation. Persistent capabilities, three-way introductions, and distributed equality are not yet implemented.</p>

<h2 id="sample_code">Sample Code</h2>

<p>The <a href="https://github.com/kentonv/capnproto/tree/master/c++/samples">Calculator example</a> implements a fully-functional Cap’n Proto client and server.</p>

<h2 id="kj_concurrency_framework">KJ Concurrency Framework</h2>

<p>RPC naturally requires a notion of concurrency. Unfortunately, <a href="https://plus.google.com/u/0/+KentonVarda/posts/D95XKtB5DhK">all concurrency models suck</a>.</p>

<p>Cap’n Proto’s RPC is based on the <a href="cxx.html#kj_library">KJ library</a>’s event-driven concurrency framework. The core of the KJ asynchronous framework (events, promises, callbacks) is defined in <code>kj/async.h</code>, with I/O interfaces (streams, sockets, networks) defined in <code>kj/async-io.h</code>.</p>

<h3 id="event_loop_concurrency">Event Loop Concurrency</h3>

<p>KJ’s concurrency model is based on event loops. While multiple threads are allowed, each thread must have its own event loop. KJ discourages fine-grained interaction between threads as synchronization is expensive and error-prone. Instead, threads are encouraged to communicate through Cap’n Proto RPC.</p>

<p>KJ’s event loop model bears a lot of similarity to the Javascript concurrency model. Experienced Javascript hackers – especially node.js hackers – will feel right at home.</p>

<p><em>As of version 0.4, the only supported way to communicate between threads is over pipes or socketpairs. This will be improved in future versions. For now, just set up an RPC connection over that socketpair. :)</em></p>

<h3 id="promises">Promises</h3>

<p>Function calls that do I/O must do so asynchronously, and must return a “promise” for the result. Promises – also known as “futures” in some systems – are placeholders for the results of operations that have not yet completed. When the operation completes, we say that the promise “resolves” to a value, or is “fulfilled”. A promise can also be “rejected”, which means an exception occurred.</p>
<div class='highlight'><pre><code class='c++'><span class='c1'>// Example promise-based interfaces.</span>

<span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>fetchHttp</span><span class='p'>(</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>StringPtr</span> <span class='n'>url</span><span class='p'>);</span>
<span class='c1'>// Asynchronously fetches an HTTP document and returns</span>
<span class='c1'>// the content as a string.</span>

<span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>void</span><span class='o'>&gt;</span> <span class='n'>sendEmail</span><span class='p'>(</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>StringPtr</span> <span class='n'>address</span><span class='p'>,</span>
    <span class='n'>kj</span><span class='o'>::</span><span class='n'>StringPtr</span> <span class='n'>title</span><span class='p'>,</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>StringPtr</span> <span class='n'>body</span><span class='p'>);</span>
<span class='c1'>// Sends an e-mail to the given address with the given title</span>
<span class='c1'>// and body.  The returned promise resolves (to nothing) when</span>
<span class='c1'>// the message has been successfully sent.</span>
</code></pre></div>
<p>As you will see, KJ promises are very similar to the evolving Javascript promise standard, and much of the <a href="https://www.google.com/search?q=javascript+promises">wisdom around it</a> can be directly applied to KJ promises.</p>

<h3 id="callbacks">Callbacks</h3>

<p>If you want to do something with the result of a promise, you must first wait for it to complete. This is normally done by registering a callback to execute on completion. Luckily, C++11 just introduced lambdas, which makes this far more pleasant than it would have been a few years ago!</p>
<div class='highlight'><pre><code class='c++'><span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>contentPromise</span> <span class='o'>=</span>
    <span class='n'>fetchHttp</span><span class='p'>(</span><span class='s'>&quot;http://example.com&quot;</span><span class='p'>);</span>

<span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>int</span><span class='o'>&gt;</span> <span class='n'>lineCountPromise</span> <span class='o'>=</span>
    <span class='n'>contentPromise</span><span class='p'>.</span><span class='n'>then</span><span class='p'>([](</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span><span class='o'>&amp;&amp;</span> <span class='n'>content</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>countChars</span><span class='p'>(</span><span class='n'>content</span><span class='p'>,</span> <span class='sc'>&#39;\n&#39;</span><span class='p'>);</span>
<span class='p'>});</span>
</code></pre></div>
<p>The callback passed to <code>then()</code> takes the promised result as its parameter and returns a new value. <code>then()</code> itself returns a new promise for that value which the callback will eventually return. If the callback itself returns a promise, then <code>then()</code> actually returns a promise for the resolution of the latter promise – that is, <code>Promise&lt;Promise&lt;T&gt;&gt;</code> is automatically reduced to <code>Promise&lt;T&gt;</code>.</p>

<p>Note that <code>then()</code> consumes the original promise: you can only call <code>then()</code> once. This is true of all of the methods of <code>Promise</code>. The only way to consume a promise in multiple places is to first “fork” it with the <code>fork()</code> method, which we don’t get into here. Relatedly, promises are linear types, which means they have move constructors but not copy constructors.</p>

<h3 id="error_propagation">Error Propagation</h3>

<p><code>then()</code> takes an optional second parameter for handling errors. Think of this like a <code>catch</code> block.</p>
<div class='highlight'><pre><code class='c++'><span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>int</span><span class='o'>&gt;</span> <span class='n'>lineCountPromise</span> <span class='o'>=</span>
    <span class='n'>promise</span><span class='p'>.</span><span class='n'>then</span><span class='p'>([](</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span><span class='o'>&amp;&amp;</span> <span class='n'>content</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>countChars</span><span class='p'>(</span><span class='n'>content</span><span class='p'>,</span> <span class='sc'>&#39;\n&#39;</span><span class='p'>);</span>
<span class='p'>},</span> <span class='p'>[](</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>Exception</span><span class='o'>&amp;&amp;</span> <span class='n'>exception</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// Error!  Pretend the document was empty.</span>
  <span class='k'>return</span> <span class='mi'>0</span><span class='p'>;</span>
<span class='p'>});</span>
</code></pre></div>
<p>Note that the KJ framework coerces all exceptions to <code>kj::Exception</code> – the exception’s description (as returned by <code>what()</code>) will be retained, but any type-specific information is lost. Under KJ exception philosophy, exceptions always represent an error that should not occur under normal operation, and the only purpose of exceptions is to make software fault-tolerant. In particular, the only reasonable ways to handle an exception are to try again, tell a human, and/or propagate to the caller. To that end, <code>kj::Exception</code> contains information useful for reporting purposes and to help decide if trying again is reasonable, but typed exception hierarchies are not useful and not supported.</p>

<p>It is recommended that Cap’n Proto code use the assertion macros in <code>kj/debug.h</code> to throw exceptions rather than use the C++ <code>throw</code> keyword. These macros make it easy to add useful debug information to an exception and generally play nicely with the KJ framework. In fact, you can even use these macros – and propagate exceptions through promises – if you compile your code with exceptions disabled. See the headers for more information.</p>

<h3 id="waiting">Waiting</h3>

<p>It is illegal for code running in an event callback to wait, since this would stall the event loop. However, if you are the one responsible for starting the event loop in the first place, then KJ makes it easy to say “run the event loop until this promise resolves, then return the result”.</p>
<div class='highlight'><pre><code class='c++'><span class='n'>kj</span><span class='o'>::</span><span class='n'>EventLoop</span> <span class='n'>loop</span><span class='p'>;</span>
<span class='n'>kj</span><span class='o'>::</span><span class='n'>WaitScope</span> <span class='n'>waitScope</span><span class='p'>(</span><span class='n'>loop</span><span class='p'>);</span>

<span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span><span class='o'>&gt;</span> <span class='n'>contentPromise</span> <span class='o'>=</span>
    <span class='n'>fetchHttp</span><span class='p'>(</span><span class='s'>&quot;http://example.com&quot;</span><span class='p'>);</span>

<span class='n'>kj</span><span class='o'>::</span><span class='n'>String</span> <span class='n'>content</span> <span class='o'>=</span> <span class='n'>contentPromise</span><span class='p'>.</span><span class='n'>wait</span><span class='p'>(</span><span class='n'>waitScope</span><span class='p'>);</span>

<span class='kt'>int</span> <span class='n'>lineCount</span> <span class='o'>=</span> <span class='n'>countChars</span><span class='p'>(</span><span class='n'>content</span><span class='p'>,</span> <span class='sc'>&#39;\n&#39;</span><span class='p'>);</span>
</code></pre></div>
<p>Using <code>wait()</code> is common in high-level client-side code. On the other hand, it is almost never used in servers.</p>

<h3 id="cancellation">Cancellation</h3>

<p>If you discard a <code>Promise</code> without calling any of its methods, the operation it was waiting for is canceled, because the <code>Promise</code> itself owns that operation. This means than any pending callbacks simply won’t be executed. If you need explicit notification when a promise is canceled, you can use its <code>attach()</code> method to attach an object with a destructor – the destructor will be called when the promise either completes or is canceled.</p>

<h3 id="other_features">Other Features</h3>

<p>KJ supports a number of primitive operations that can be performed on promises. The complete API is documented directly in the <code>kj/async.h</code> header. Additionally, see the <code>kj/async-io.h</code> header for APIs for performing basic network I/O – although Cap’n Proto RPC users typically won’t need to use these APIs directly.</p>

<h2 id="generated_code">Generated Code</h2>

<p>Imagine the following interface:</p>
<div class='highlight'><pre><code class='capnp'><span class='k'>interface</span> <span class='n'>Directory</span> {
  <span class='n'>create</span> <span class='nd'>@0</span> (<span class='n'>name</span> <span class='nc'>:Text</span>) -&gt; (<span class='n'>file</span> <span class='nc'>:File</span>);
  <span class='n'>open</span> <span class='nd'>@1</span> (<span class='n'>name</span> <span class='nc'>:Text</span>) -&gt; (<span class='n'>file</span> <span class='nc'>:File</span>);
  <span class='n'>remove</span> <span class='nd'>@2</span> (<span class='n'>name</span> <span class='nc'>:Text</span>);
}
</code></pre></div>
<p><code>capnp compile</code> will generate code that looks like this (edited for readability):</p>
<div class='highlight'><pre><code class='c++'><span class='k'>struct</span> <span class='n'>Directory</span> <span class='p'>{</span>
  <span class='n'>Directory</span><span class='p'>()</span> <span class='o'>=</span> <span class='k'>delete</span><span class='p'>;</span>

  <span class='k'>class</span> <span class='nc'>Client</span><span class='p'>;</span>
  <span class='k'>class</span> <span class='nc'>Server</span><span class='p'>;</span>

  <span class='k'>struct</span> <span class='n'>CreateParams</span><span class='p'>;</span>
  <span class='k'>struct</span> <span class='n'>CreateResults</span><span class='p'>;</span>
  <span class='k'>struct</span> <span class='n'>OpenParams</span><span class='p'>;</span>
  <span class='k'>struct</span> <span class='n'>OpenResults</span><span class='p'>;</span>
  <span class='k'>struct</span> <span class='n'>RemoveParams</span><span class='p'>;</span>
  <span class='k'>struct</span> <span class='n'>RemoveResults</span><span class='p'>;</span>
  <span class='c1'>// Each of these is equivalent to what would be generated for</span>
  <span class='c1'>// a Cap&#39;n Proto struct with one field for each parameter /</span>
  <span class='c1'>// result.</span>
<span class='p'>};</span>

<span class='k'>class</span> <span class='nc'>Directory</span><span class='o'>::</span><span class='n'>Client</span>
    <span class='o'>:</span> <span class='k'>public</span> <span class='k'>virtual</span> <span class='n'>capnp</span><span class='o'>::</span><span class='n'>Capability</span><span class='o'>::</span><span class='n'>Client</span> <span class='p'>{</span>
<span class='nl'>public:</span>
  <span class='n'>Client</span><span class='p'>(</span><span class='n'>std</span><span class='o'>::</span><span class='kt'>nullptr_t</span><span class='p'>);</span>
  <span class='n'>Client</span><span class='p'>(</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>Own</span><span class='o'>&lt;</span><span class='n'>Directory</span><span class='o'>::</span><span class='n'>Server</span><span class='o'>&gt;</span> <span class='n'>server</span><span class='p'>);</span>
  <span class='n'>Client</span><span class='p'>(</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='n'>Client</span><span class='o'>&gt;</span> <span class='n'>promise</span><span class='p'>);</span>
  <span class='n'>Client</span><span class='p'>(</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>Exception</span> <span class='n'>exception</span><span class='p'>);</span>

  <span class='n'>capnp</span><span class='o'>::</span><span class='n'>Request</span><span class='o'>&lt;</span><span class='n'>CreateParams</span><span class='p'>,</span> <span class='n'>CreateResults</span><span class='o'>&gt;</span> <span class='n'>createRequest</span><span class='p'>();</span>
  <span class='n'>capnp</span><span class='o'>::</span><span class='n'>Request</span><span class='o'>&lt;</span><span class='n'>OpenParams</span><span class='p'>,</span> <span class='n'>OpenResults</span><span class='o'>&gt;</span> <span class='n'>openRequest</span><span class='p'>();</span>
  <span class='n'>capnp</span><span class='o'>::</span><span class='n'>Request</span><span class='o'>&lt;</span><span class='n'>RemoveParams</span><span class='p'>,</span> <span class='n'>RemoveResults</span><span class='o'>&gt;</span> <span class='n'>removeRequest</span><span class='p'>();</span>
<span class='p'>};</span>

<span class='k'>class</span> <span class='nc'>Directory</span><span class='o'>::</span><span class='n'>Server</span>
    <span class='o'>:</span> <span class='k'>public</span> <span class='k'>virtual</span> <span class='n'>capnp</span><span class='o'>::</span><span class='n'>Capability</span><span class='o'>::</span><span class='n'>Server</span> <span class='p'>{</span>
<span class='nl'>protected:</span>
  <span class='k'>typedef</span> <span class='n'>capnp</span><span class='o'>::</span><span class='n'>CallContext</span><span class='o'>&lt;</span><span class='n'>CreateParams</span><span class='p'>,</span> <span class='n'>CreateResults</span><span class='o'>&gt;</span> <span class='n'>CreateContext</span><span class='p'>;</span>
  <span class='k'>typedef</span> <span class='n'>capnp</span><span class='o'>::</span><span class='n'>CallContext</span><span class='o'>&lt;</span><span class='n'>OpenParams</span><span class='p'>,</span> <span class='n'>OpenResults</span><span class='o'>&gt;</span> <span class='n'>OpenContext</span><span class='p'>;</span>
  <span class='k'>typedef</span> <span class='n'>capnp</span><span class='o'>::</span><span class='n'>CallContext</span><span class='o'>&lt;</span><span class='n'>RemoveParams</span><span class='p'>,</span> <span class='n'>RemoveResults</span><span class='o'>&gt;</span> <span class='n'>RemoveContext</span><span class='p'>;</span>
  <span class='c1'>// Convenience typedefs.</span>

  <span class='k'>virtual</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>void</span><span class='o'>&gt;</span> <span class='n'>create</span><span class='p'>(</span><span class='n'>CreateContext</span> <span class='n'>context</span><span class='p'>);</span>
  <span class='k'>virtual</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>void</span><span class='o'>&gt;</span> <span class='n'>open</span><span class='p'>(</span><span class='n'>OpenContext</span> <span class='n'>context</span><span class='p'>);</span>
  <span class='k'>virtual</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>void</span><span class='o'>&gt;</span> <span class='n'>remove</span><span class='p'>(</span><span class='n'>RemoveContext</span> <span class='n'>context</span><span class='p'>);</span>
  <span class='c1'>// Methods for you to implement.</span>
<span class='p'>};</span>
</code></pre></div>
<h3 id="clients">Clients</h3>

<p>The generated <code>Client</code> type represents a reference to a remote <code>Server</code>. <code>Client</code>s are pass-by-value types that use reference counting under the hood. (Warning: For performance reasons, the reference counting used by <code>Client</code>s is not thread-safe, so you must not copy a <code>Client</code> to another thread, unless you do it by means of an inter-thread RPC.)</p>

<p>A <code>Client</code> can be implicitly constructed from any of:</p>

<ul>
<li>A <code>kj::Own&lt;Server&gt;</code>, which takes ownership of the server object and creates a client that calls it. (You can get a <code>kj::Own&lt;T&gt;</code> to a newly-allocated heap object using <code>kj::heap&lt;T&gt;(constructorParams)</code>; see <code>kj/memory.h</code>.)</li>

<li>A <code>kj::Promise&lt;Client&gt;</code>, which creates a client whose methods first wait for the promise to resolve, then forward the call to the resulting client.</li>

<li>A <code>kj::Exception</code>, which creates a client whose methods always throw that exception.</li>

<li><code>nullptr</code>, which creates a client whose methods always throw. This is meant to be used to initialize variables that will be initialized to a real value later on.</li>
</ul>

<p>For each interface method <code>foo()</code>, the <code>Client</code> has a method <code>fooRequest()</code> which creates a new request to call <code>foo()</code>. The returned <code>capnp::Request</code> object has methods equivalent to a <code>Builder</code> for the parameter struct (<code>FooParams</code>), with the addition of a method <code>send()</code>. <code>send()</code> sends the RPC and returns a <code>capnp::RemotePromise&lt;FooResults&gt;</code>.</p>

<p>This <code>RemotePromise</code> is equivalent to <code>kj::Promise&lt;capnp::Response&lt;FooResults&gt;&gt;</code>, but also has methods that allow pipelining. Namely:</p>

<ul>
<li>For each interface-typed result, it has a getter method which returns a <code>Client</code> of that type. Calling this client will send a pipelined call to the server.</li>

<li>For each struct-typed result, it has a getter method which returns an object containing pipeline getters for that struct’s fields.</li>
</ul>

<p>In other words, the <code>RemotePromise</code> effectively implements a subset of the eventual results’ <code>Reader</code> interface – one that only allows access to interfaces and sub-structs.</p>

<p>The <code>RemotePromise</code> eventually resolves to <code>capnp::Response&lt;FooResults&gt;</code>, which behaves like a <code>Reader</code> for the result struct except that it also owns the result message.</p>
<div class='highlight'><pre><code class='c++'><span class='n'>Directory</span><span class='o'>::</span><span class='n'>Client</span> <span class='n'>dir</span> <span class='o'>=</span> <span class='p'>...;</span>

<span class='c1'>// Create a new request for the `open()` method.</span>
<span class='k'>auto</span> <span class='n'>request</span> <span class='o'>=</span> <span class='n'>dir</span><span class='p'>.</span><span class='n'>openRequest</span><span class='p'>();</span>
<span class='n'>request</span><span class='p'>.</span><span class='n'>setName</span><span class='p'>(</span><span class='s'>&quot;foo&quot;</span><span class='p'>);</span>

<span class='c1'>// Send the request.</span>
<span class='k'>auto</span> <span class='n'>promise</span> <span class='o'>=</span> <span class='n'>request</span><span class='p'>.</span><span class='n'>send</span><span class='p'>();</span>

<span class='c1'>// Make a pipelined request.</span>
<span class='k'>auto</span> <span class='n'>promise2</span> <span class='o'>=</span> <span class='n'>promise</span><span class='p'>.</span><span class='n'>getFile</span><span class='p'>().</span><span class='n'>getSizeRequest</span><span class='p'>().</span><span class='n'>send</span><span class='p'>();</span>

<span class='c1'>// Wait for the full results.</span>
<span class='k'>auto</span> <span class='n'>promise3</span> <span class='o'>=</span> <span class='n'>promise2</span><span class='p'>.</span><span class='n'>then</span><span class='p'>(</span>
    <span class='p'>[](</span><span class='n'>capnp</span><span class='o'>::</span><span class='n'>Response</span><span class='o'>&lt;</span><span class='n'>File</span><span class='o'>::</span><span class='n'>GetSizeResults</span><span class='o'>&gt;&amp;&amp;</span> <span class='n'>response</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;File size is: &quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>response</span><span class='p'>.</span><span class='n'>getSize</span><span class='p'>()</span> <span class='o'>&lt;&lt;</span> <span class='n'>endl</span><span class='p'>;</span>
<span class='p'>});</span>
</code></pre></div>
<h3 id="servers">Servers</h3>

<p>The generated <code>Server</code> type is an abstract interface which may be subclassed to implement a capability. Each method takes a <code>context</code> argument and returns a <code>kj::Promise&lt;void&gt;</code> which resolves when the call is finished. The parameter and result structures are accessed through the context – <code>context.getParams()</code> returns a <code>Reader</code> for the parameters, and <code>context.getResults()</code> returns a <code>Builder</code> for the results. The context also has methods for controlling RPC logistics, such as cancellation – see <code>capnp::CallContext</code> in <code>capnp/capability.h</code> for details.</p>

<p>Accessing the results through the context (rather than by returning them) is unintuitive, but necessary because the underlying RPC transport needs to have control over where the results are allocated. For example, a zero-copy shared memory transport would need to allocate the results in the shared memory segment. Hence, the method implementation cannot just create its own <code>MessageBuilder</code>.</p>
<div class='highlight'><pre><code class='c++'><span class='k'>class</span> <span class='nc'>DirectoryImpl</span> <span class='n'>final</span><span class='o'>:</span> <span class='k'>public</span> <span class='n'>Directory</span><span class='o'>::</span><span class='n'>Server</span> <span class='p'>{</span>
<span class='nl'>public:</span>
  <span class='n'>kj</span><span class='o'>::</span><span class='n'>Promise</span><span class='o'>&lt;</span><span class='kt'>void</span><span class='o'>&gt;</span> <span class='n'>open</span><span class='p'>(</span><span class='n'>OpenContext</span> <span class='n'>context</span><span class='p'>)</span> <span class='n'>override</span> <span class='p'>{</span>
    <span class='k'>auto</span> <span class='n'>iter</span> <span class='o'>=</span> <span class='n'>files</span><span class='p'>.</span><span class='n'>find</span><span class='p'>(</span><span class='n'>context</span><span class='p'>.</span><span class='n'>getRequest</span><span class='p'>().</span><span class='n'>getName</span><span class='p'>());</span>

    <span class='c1'>// Throw an exception if not found.</span>
    <span class='n'>KJ_REQUIRE</span><span class='p'>(</span><span class='n'>iter</span> <span class='o'>!=</span> <span class='n'>files</span><span class='p'>.</span><span class='n'>end</span><span class='p'>(),</span> <span class='s'>&quot;File not found.&quot;</span><span class='p'>);</span>

    <span class='n'>context</span><span class='p'>.</span><span class='n'>getResults</span><span class='p'>().</span><span class='n'>setFile</span><span class='p'>(</span><span class='n'>iter</span><span class='o'>-&gt;</span><span class='n'>second</span><span class='p'>);</span>

    <span class='k'>return</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>READY_NOW</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Any method which we don&#39;t implement will simply throw</span>
  <span class='c1'>// an exception by default.</span>

<span class='nl'>private:</span>
  <span class='n'>std</span><span class='o'>::</span><span class='n'>map</span><span class='o'>&lt;</span><span class='n'>kj</span><span class='o'>::</span><span class='n'>StringPtr</span><span class='p'>,</span> <span class='n'>File</span><span class='o'>::</span><span class='n'>Client</span><span class='o'>&gt;</span> <span class='n'>files</span><span class='p'>;</span>
<span class='p'>};</span>
</code></pre></div>
<h2 id="initializing_rpc">Initializing RPC</h2>

<p>Cap’n Proto makes it easy to start up an RPC client or server using the “EZ RPC” classes, defined in <code>capnp/ez-rpc.h</code>. These classes get you up and running quickly, but they hide a lot of details that power users will likely want to manipulate. Check out the comments in <code>ez-rpc.h</code> to understand exactly what you get and what you miss. For the purpose of this overview, we’ll show you how to use EZ RPC to get started.</p>

<h3 id="starting_a_client">Starting a client</h3>

<p>A client should typically look like this:</p>
<div class='highlight'><pre><code class='c++'><span class='cp'>#include &lt;capnp/ez-rpc.h&gt;</span>
<span class='cp'>#include &quot;my-interface.capnp.h&quot;</span>
<span class='cp'>#include &lt;iostream&gt;</span>

<span class='kt'>int</span> <span class='nf'>main</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>argc</span><span class='p'>,</span> <span class='k'>const</span> <span class='kt'>char</span><span class='o'>*</span> <span class='n'>argv</span><span class='p'>[])</span> <span class='p'>{</span>
  <span class='c1'>// We expect one argument specifying the server address.</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>argc</span> <span class='o'>!=</span> <span class='mi'>2</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>std</span><span class='o'>::</span><span class='n'>cerr</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;usage: &quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>argv</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot; HOST[:PORT]&quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>std</span><span class='o'>::</span><span class='n'>endl</span><span class='p'>;</span>
    <span class='k'>return</span> <span class='mi'>1</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Set up the EzRpcClient, connecting to the server on port</span>
  <span class='c1'>// 5923 unless a different port was specified by the user.</span>
  <span class='n'>capnp</span><span class='o'>::</span><span class='n'>EzRpcClient</span> <span class='n'>client</span><span class='p'>(</span><span class='n'>argv</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>],</span> <span class='mi'>5923</span><span class='p'>);</span>
  <span class='k'>auto</span><span class='o'>&amp;</span> <span class='n'>waitScope</span> <span class='o'>=</span> <span class='n'>client</span><span class='p'>.</span><span class='n'>getWaitScope</span><span class='p'>();</span>

  <span class='c1'>// Request the service named &quot;foo&quot; from the server.</span>
  <span class='n'>MyInterface</span><span class='o'>::</span><span class='n'>Client</span> <span class='n'>cap</span> <span class='o'>=</span>
      <span class='n'>client</span><span class='p'>.</span><span class='n'>importCap</span><span class='o'>&lt;</span><span class='n'>MyInterface</span><span class='o'>&gt;</span><span class='p'>(</span><span class='s'>&quot;foo&quot;</span><span class='p'>);</span>

  <span class='c1'>// Make a call to the capability.</span>
  <span class='k'>auto</span> <span class='n'>request</span> <span class='o'>=</span> <span class='n'>cap</span><span class='p'>.</span><span class='n'>fooRequest</span><span class='p'>();</span>
  <span class='n'>request</span><span class='p'>.</span><span class='n'>setParam</span><span class='p'>(</span><span class='mi'>123</span><span class='p'>);</span>
  <span class='k'>auto</span> <span class='n'>promise</span> <span class='o'>=</span> <span class='n'>request</span><span class='p'>.</span><span class='n'>send</span><span class='p'>();</span>

  <span class='c1'>// Wait for the result.  This is the only line that blocks.</span>
  <span class='k'>auto</span> <span class='n'>response</span> <span class='o'>=</span> <span class='n'>promise</span><span class='p'>.</span><span class='n'>wait</span><span class='p'>(</span><span class='n'>waitScope</span><span class='p'>);</span>

  <span class='c1'>// All done.</span>
  <span class='n'>std</span><span class='o'>::</span><span class='n'>cout</span> <span class='o'>&lt;&lt;</span> <span class='n'>response</span><span class='p'>.</span><span class='n'>getResult</span><span class='p'>()</span> <span class='o'>&lt;&lt;</span> <span class='n'>std</span><span class='o'>::</span><span class='n'>endl</span><span class='p'>;</span>
  <span class='k'>return</span> <span class='mi'>0</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre></div>
<p>Note that for the connect address, Cap’n Proto supports DNS host names as well as IPv4 and IPv6 addresses. Additionally, a Unix domain socket can be specified as <code>unix:</code> followed by a path name.</p>

<p>For a more complete example, see the <a href="https://github.com/kentonv/capnproto/tree/master/c++/samples/calculator-client.c++">calculator client sample</a>.</p>

<h3 id="starting_a_server">Starting a server</h3>

<p>A server might look something like this:</p>
<div class='highlight'><pre><code class='c++'><span class='cp'>#include &lt;capnp/ez-rpc.h&gt;</span>
<span class='cp'>#include &quot;my-interface-impl.h&quot;</span>
<span class='cp'>#include &lt;iostream&gt;</span>

<span class='kt'>int</span> <span class='nf'>main</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>argc</span><span class='p'>,</span> <span class='k'>const</span> <span class='kt'>char</span><span class='o'>*</span> <span class='n'>argv</span><span class='p'>[])</span> <span class='p'>{</span>
  <span class='c1'>// We expect one argument specifying the address to which</span>
  <span class='c1'>// to bind and accept connections.</span>
  <span class='k'>if</span> <span class='p'>(</span><span class='n'>argc</span> <span class='o'>!=</span> <span class='mi'>2</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>std</span><span class='o'>::</span><span class='n'>cerr</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot;usage: &quot;</span> <span class='o'>&lt;&lt;</span> <span class='n'>argv</span><span class='p'>[</span><span class='mi'>0</span><span class='p'>]</span> <span class='o'>&lt;&lt;</span> <span class='s'>&quot; ADDRESS[:PORT]&quot;</span>
              <span class='o'>&lt;&lt;</span> <span class='n'>std</span><span class='o'>::</span><span class='n'>endl</span><span class='p'>;</span>
    <span class='k'>return</span> <span class='mi'>1</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Set up the EzRpcServer, binding to port 5923 unless a</span>
  <span class='c1'>// different port was specified by the user.</span>
  <span class='n'>capnp</span><span class='o'>::</span><span class='n'>EzRpcServer</span> <span class='n'>server</span><span class='p'>(</span><span class='n'>argv</span><span class='p'>[</span><span class='mi'>1</span><span class='p'>],</span> <span class='mi'>5923</span><span class='p'>);</span>
  <span class='k'>auto</span><span class='o'>&amp;</span> <span class='n'>waitScope</span> <span class='o'>=</span> <span class='n'>server</span><span class='p'>.</span><span class='n'>getWaitScope</span><span class='p'>();</span>

  <span class='c1'>// Export a capability under the name &quot;foo&quot;.  Note that the</span>
  <span class='c1'>// second parameter here can be any &quot;Client&quot; object or anything</span>
  <span class='c1'>// that can implicitly cast to a &quot;Client&quot; object.  You can even</span>
  <span class='c1'>// re-export a capability imported from another server.</span>
  <span class='n'>server</span><span class='p'>.</span><span class='n'>exportCap</span><span class='p'>(</span><span class='s'>&quot;foo&quot;</span><span class='p'>,</span> <span class='n'>kj</span><span class='o'>::</span><span class='n'>heap</span><span class='o'>&lt;</span><span class='n'>MyInterfaceImpl</span><span class='o'>&gt;</span><span class='p'>());</span>

  <span class='c1'>// Run forever, accepting connections and handling requests.</span>
  <span class='n'>kj</span><span class='o'>::</span><span class='n'>NEVER_DONE</span><span class='p'>.</span><span class='n'>wait</span><span class='p'>(</span><span class='n'>waitScope</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre></div>
<p>Note that for the bind address, Cap’n Proto supports DNS host names as well as IPv4 and IPv6 addresses. The special address <code>*</code> can be used to bind to the same port on all local IPv4 and IPv6 interfaces. Additionally, a Unix domain socket can be specified as <code>unix:</code> followed by a path name.</p>

<p>For a more complete example, see the <a href="https://github.com/kentonv/capnproto/tree/master/c++/samples/calculator-server.c++">calculator server sample</a>.</p>

<h2 id="debugging">Debugging</h2>

<p>If you’ve written a server and you want to connect to it to issue some calls for debugging, perhaps interactively, the easiest way to do it is to use <a href="http://jparyani.github.io/pycapnp/">pycapnp</a>. We have decided not to add RPC functionality to the <code>capnp</code> command-line tool because pycapnp is better than anything we might provide.</p>
<script type="text/javascript">setupSidebar()</script>
        <div style="clear: both;"></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cap'n Proto maintained by <a href="https://github.com/kentonv">kentonv</a>
          <span class="gplus-followbutton"><span class="g-follow" data-annotation="bubble" data-height="15" data-href="//plus.google.com/118187272963262049674" data-rel="author"></span></span>
          <a href="https://www.gittip.com/kentonv/"><img class="gittip15" src="/capnproto/next/images/gittip15.png" alt="Gittip"></a></p>
        <p>Design by <a href="http://www.starfruit-cafe.net/blog">sailorhg</a> ∙ Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    <!-- Google+ follow button. -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>

    <!-- Google Analytics. -->
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-39711112-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>
  </body>
</html>

