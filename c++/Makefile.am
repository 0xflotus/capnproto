## Process this file with automake to produce Makefile.in

ACLOCAL_AMFLAGS = -I m4

AUTOMAKE_OPTIONS = foreign

AM_CXXFLAGS = -I$(srcdir)/src -I$(builddir)/src

EXTRA_DIST =                                                                 \
  README.txt                                                                 \
  LICENSE.txt                                                                \
  $(test_capnpc_inputs)

CLEANFILES = $(capnpc_outputs) $(test_capnpc_outputs) capnpc_middleman test_capnpc_middleman

# Deletes all the files generated by autoreconf.
MAINTAINERCLEANFILES =   \
  aclocal.m4             \
  config.guess           \
  config.sub             \
  configure              \
  depcomp                \
  install-sh             \
  ltmain.sh              \
  Makefile.in            \
  missing                \
  mkinstalldirs          \
  config.h.in            \
  stamp.h.in             \
  m4/ltsugar.m4          \
  m4/libtool.m4          \
  m4/ltversion.m4        \
  m4/lt~obsolete.m4      \
  m4/ltoptions.m4

maintainer-clean-local:
	-rm -rf build-aux

# gmake defines an implicit rule building n from n.o.  Unfortunately, this triggers on our .capnp
# files because they generate .capnp.c++ which is compiled to .capnp.o.  In addition to being
# nonsense, this leads to cyclic dependency issues and could even cause the .capnp files to be
# unexpectedly overwritten!  We need to cancel the implicit rule by declaring an explicit one.
#
# I want the hours of my life back that I spent figuring this out.
%.capnp:
	@:

# Implicit rules for invoking capnpc.
%.capnp.h: %.capnp
	$(CAPNPC) --src-prefix=$(srcdir) -oc++ $^
%.capnp.c++: %.capnp.h
	@:

public_capnpc_inputs =                                         \
  src/capnp/c++.capnp                                          \
  src/capnp/schema.capnp

capnpc_inputs = $(public_capnpc_inputs)

capnpc_outputs =                                               \
  src/capnp/c++.capnp.c++                                      \
  src/capnp/c++.capnp.h                                        \
  src/capnp/schema.capnp.c++                                   \
  src/capnp/schema.capnp.h

includecapnpdir = $(includedir)/capnp
includekjdir = $(includedir)/kj

dist_includecapnp_DATA = $(public_capnpc_inputs)

includekj_HEADERS =                                            \
  src/kj/common.h                                              \
  src/kj/units.h                                               \
  src/kj/memory.h                                              \
  src/kj/array.h                                               \
  src/kj/vector.h                                              \
  src/kj/string.h                                              \
  src/kj/exception.h                                           \
  src/kj/debug.h                                               \
  src/kj/io.h                                                  \
  src/kj/tuple.h                                               \
  src/kj/parse.h

includecapnp_HEADERS =                                         \
  src/capnp/common.h                                           \
  src/capnp/blob.h                                             \
  src/capnp/endian.h                                           \
  src/capnp/layout.h                                           \
  src/capnp/list.h                                             \
  src/capnp/message.h                                          \
  src/capnp/schema.h                                           \
  src/capnp/schema-loader.h                                    \
  src/capnp/dynamic.h                                          \
  src/capnp/serialize.h                                        \
  src/capnp/serialize-packed.h                                 \
  src/capnp/generated-header-support.h
nodist_includecapnp_HEADERS =                                  \
  src/capnp/schema.capnp.h

# No dynamic library for now since C++ binary compatibility is hard.
# It may make more sense to have every module statically link Cap'n Proto
# and pass around messages via memory pointers.
lib_LIBRARIES = libcapnp.a

libcapnp_a_SOURCES=                                            \
  src/kj/common.c++                                            \
  src/kj/units.c++                                             \
  src/kj/memory.c++                                            \
  src/kj/array.c++                                             \
  src/kj/string.c++                                            \
  src/kj/exception.c++                                         \
  src/kj/debug.c++                                             \
  src/kj/io.c++                                                \
  src/capnp/blob.c++                                           \
  src/capnp/arena.h                                            \
  src/capnp/arena.c++                                          \
  src/capnp/layout.c++                                         \
  src/capnp/list.c++                                           \
  src/capnp/message.c++                                        \
  src/capnp/schema.c++                                         \
  src/capnp/schema-loader.c++                                  \
  src/capnp/dynamic.c++                                        \
  src/capnp/stringify.c++                                      \
  src/capnp/serialize.c++                                      \
  src/capnp/serialize-packed.c++
nodist_libcapnp_a_SOURCES =                                    \
  src/capnp/schema.capnp.c++                                   \
  src/capnp/c++.capnp.c++

# Source files intentionally not included in the dist at this time:
#  src/capnp/serialize-snappy*
#  src/capnp/benchmark/...
#  src/capnp/compiler/...

# Tests ==============================================================

test_capnpc_inputs =                                           \
  src/capnp/test.capnp                                         \
  src/capnp/test-import.capnp

test_capnpc_outputs =                                          \
  src/capnp/test.capnp.c++                                     \
  src/capnp/test.capnp.h                                       \
  src/capnp/test-import.capnp.c++                              \
  src/capnp/test-import.capnp.h

BUILT_SOURCES = $(test_capnpc_outputs) $(capnpc_outputs)

check_PROGRAMS = capnp-test
capnp_test_LDADD = -lgtest -lgtest_main libcapnp.a
capnp_test_SOURCES =                                           \
  src/kj/common-test.c++                                       \
  src/kj/memory-test.c++                                       \
  src/kj/array-test.c++                                        \
  src/kj/string-test.c++                                       \
  src/kj/exception-test.c++                                    \
  src/kj/debug-test.c++                                        \
  src/kj/units-test.c++                                        \
  src/kj/tuple-test.c++                                        \
  src/kj/parse-test.c++                                        \
  src/capnp/blob-test.c++                                      \
  src/capnp/endian-test.c++                                    \
  src/capnp/endian-fallback-test.c++                           \
  src/capnp/endian-reverse-test.c++                            \
  src/capnp/layout-test.c++                                    \
  src/capnp/message-test.c++                                   \
  src/capnp/schema-test.c++                                    \
  src/capnp/schema-loader-test.c++                             \
  src/capnp/dynamic-test.c++                                   \
  src/capnp/stringify-test.c++                                 \
  src/capnp/encoding-test.c++                                  \
  src/capnp/serialize-test.c++                                 \
  src/capnp/serialize-packed-test.c++                          \
  src/capnp/test-util.c++                                      \
  src/capnp/test-util.h
nodist_capnp_test_SOURCES = $(test_capnpc_outputs)

TESTS = capnp-test
