// Copyright (c) 2013, Kenton Varda <temporal@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <cstddef>
#include <memory>
#include "macros.h"
#include "type-safety.h"
#include "wire-format.h"
#include "message-internal.h"

#ifndef CAPNPROTO_MESSAGE_H_
#define CAPNPROTO_MESSAGE_H_

namespace capnproto {

class Segment;
typedef Id<uint32_t, Segment> SegmentId;

// =======================================================================================

class Allocator {
public:
  virtual ~Allocator();

  virtual ArrayPtr<word> allocate(SegmentId id, uint minimumSize) = 0;
  virtual void free(SegmentId id, ArrayPtr<word> ptr) = 0;
};

class ErrorReporter {
public:
  virtual ~ErrorReporter();

  virtual void reportError(const char* description) = 0;
};

// =======================================================================================

template <typename RootType>
struct Message {
  Message() = delete;

  class Reader {
  public:
    Reader(ArrayPtr<const ArrayPtr<const word>> segments,
           uint recursionLimit, uint64_t readLimit, ErrorReporter* errorReporter);
    Reader(Reader&& other) = default;
    CAPNPROTO_DISALLOW_COPY(Reader);

    typename RootType::Reader getRoot();

  private:
    internal::MessageImpl::Reader internal;
  };

  class Builder {
  public:
    Builder();
    // Make a Builder that allocates using malloc, using the default segment size.

    Builder(Allocator* allocator);
    // Make a Builder that allocates memory using the given allocator.

    Builder(Builder&& other) = default;
    CAPNPROTO_DISALLOW_COPY(Builder);

    typename RootType::Builder initRoot();
    typename RootType::Builder getRoot();

    ArrayPtr<const ArrayPtr<const word>> getSegmentsForOutput();

  private:
    internal::MessageImpl::Builder internal;
  };

  static typename RootType::Reader readTrusted(const word* data);
  // IF THE INPUT IS INVALID, THIS MAY CRASH, CORRUPT MEMORY, CREATE A SECURITY HOLE IN YOUR APP,
  // MURDER YOUR FIRST-BORN CHILD, AND/OR BRING ABOUT ETERNAL DAMNATION ON ALL OF HUMANITY.  DO NOT
  // USE UNLESS YOU UNDERSTAND THE CONSEQUENCES.
  //
  // Given a pointer to a known-valid message located in a single contiguous memory segment,
  // returns a reader for that message.  No bounds-checking will be done while tranversing this
  // message.  Use this only if you are absolutely sure that the input data is a valid message
  // created by your own system.  Never use this to read messages received from others.
  //
  // To create a trusted message, build a message using a MallocAllocator whose preferred segment
  // size is larger than the message size.  This guarantees that the message will be allocated as a
  // single segment, meaning getSegmentsForOutput() returns a single word array.  That word array
  // is your message; you may pass a pointer to its first word into readTrusted() to read the
  // message.
  //
  // This can be particularly handy for embedding messages in generated code:  you can
  // embed the raw bytes (using AlignedData) then make a Reader for it using this.  This is the way
  // default values are embedded in code generated by the Cap'n Proto compiler.  E.g., if you have
  // a message MyMessage, you can read its default value like so:
  //    MyMessage::Reader reader = Message<MyMessage>::ReadTrusted(MyMessage::DEFAULT.words);
};

// =======================================================================================
// Standard implementations of allocators and error reporters.

class MallocAllocator: public Allocator {
public:
  explicit MallocAllocator(uint preferredSegmentSizeWords);
  ~MallocAllocator();

  static MallocAllocator* getDefaultInstance();

  // implements Allocator --------------------------------------------
  ArrayPtr<word> allocate(SegmentId id, uint minimumSize) override;
  void free(SegmentId id, ArrayPtr<word> ptr) override;

private:
  uint preferredSegmentSizeWords;
};

class StderrErrorReporter: public ErrorReporter {
public:
  ~StderrErrorReporter();

  static StderrErrorReporter* getDefaultInstance();

  // implements ErrorReporter ----------------------------------------
  void reportError(const char* description) override;
};

class ThrowingErrorReporter: public ErrorReporter {
public:
  ~ThrowingErrorReporter();

  static ThrowingErrorReporter* getDefaultInstance();

  // implements ErrorReporter ----------------------------------------
  void reportError(const char* description) override;
};

// =======================================================================================
// implementation details

template <typename RootType>
inline Message<RootType>::Reader::Reader(ArrayPtr<const ArrayPtr<const word>> segments,
       uint recursionLimit, uint64_t readLimit, ErrorReporter* errorReporter)
    : internal(segments, recursionLimit, readLimit, errorReporter) {}

template <typename RootType>
inline typename RootType::Reader Message<RootType>::Reader::getRoot() {
  return typename RootType::Reader(internal.getRoot(RootType::DEFAULT.words));
}

template <typename RootType>
inline Message<RootType>::Builder::Builder()
    : internal() {}

template <typename RootType>
inline Message<RootType>::Builder::Builder(Allocator* allocator)
    : internal(allocator) {}

template <typename RootType>
inline typename RootType::Builder Message<RootType>::Builder::initRoot() {
  return typename RootType::Builder(internal.initRoot(RootType::DEFAULT.words));
}

template <typename RootType>
inline typename RootType::Builder Message<RootType>::Builder::getRoot() {
  return typename RootType::Builder(internal.getRoot(RootType::DEFAULT.words));
}

template <typename RootType>
inline ArrayPtr<const ArrayPtr<const word>> Message<RootType>::Builder::getSegmentsForOutput() {
  return internal.getSegmentsForOutput();
}

template <typename RootType>
typename RootType::Reader Message<RootType>::readTrusted(const word* data) {
  return typename RootType::Reader(internal::StructReader::readRootTrusted(
      data, RootType::DEFAULT.words));
}

}  // namespace capnproto

#endif  // CAPNPROTO_MESSAGE_H_
