// Copyright (c) 2013, Kenton Varda <temporal@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is NOT intended for use by clients, except in generated code.
//
// This file defines low-level, non-type-safe classes for interpreting the raw Cap'n Proto wire
// format.  Code generated by the Cap'n Proto compiler uses these classes, as does other parts of
// the Cap'n proto library which provide a higher-level interface for dynamic introspection.

#ifndef CAPNPROTO_WIRE_FORMAT_H_
#define CAPNPROTO_WIRE_FORMAT_H_

#include <inttypes.h>
#include "macros.h"

namespace capnproto {
  class SegmentReader;
  class SegmentBuilder;
}

namespace capnproto {
namespace internal {

class Descriptor;
class StructDescriptor;
class ListDescriptor;

namespace debug {
  // These functions are only called inside debug asserts.  They are defined out-of-line so that
  // we don't have to #include descriptor.h from here, which is arguably important because this
  // header is #included from generated headers, whereas descriptor.h is only #included in generated
  // source files.

  bool fieldIsStruct(const StructDescriptor* descriptor, int fieldNumber, int refIndex);
  bool fieldIsList(const StructDescriptor* descriptor, int fieldNumber, int refIndex);
  bool fieldIsData(const StructDescriptor* descriptor, int fieldNumber, int dataOffset,
                   int bitSize);
  bool dataFieldInRange(const StructDescriptor* descriptor, uint32_t dataOffset, uint32_t size);
  bool bitFieldInRange(const StructDescriptor* descriptor, uint32_t offset);
  bool refFieldIsStruct(const StructDescriptor* descriptor, int refIndex);
  bool refFieldIsList(const StructDescriptor* descriptor, int refIndex);
  bool elementsAreStructs(const ListDescriptor* descriptor);
  bool elementsAreStructs(const ListDescriptor* descriptor, uint32_t wordSize);
  bool elementsAreLists(const ListDescriptor* descriptor);
  bool elementsAreData(const ListDescriptor* descriptor, int bitSize);
}  // namespace debug

class StructBuilder;
class StructReader;
class ListBuilder;
class ListReader;
struct WireReference;
struct WireHelpers;

// -------------------------------------------------------------------

template <typename T>
class WireValue {
  // Wraps a primitive value as it appears on the wire.  Namely, values are little-endian on the
  // wire, because little-endian is the most common endianness in modern CPUs.
  //
  // TODO:  On big-endian systems, inject byte-swapping here.  Most big-endian CPUs implement
  //   dedicated instructions for this, so use those rather than writing a bunch of shifts and
  //   masks.  Note that GCC has e.g. __builtin__bswap32() for this.
  //
  // Note:  In general, code that depends cares about byte ordering is bad.  See:
  //     http://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html
  //   Cap'n Proto is special because it is essentially doing compiler-like things, fussing over
  //   allocation and layout of memory, in order to squeeze out every last drop of performance.

public:
  CAPNPROTO_ALWAYS_INLINE(WireValue()) {}
  CAPNPROTO_ALWAYS_INLINE(WireValue(T value)): value(value) {}

  CAPNPROTO_ALWAYS_INLINE(T get() const) { return value; }
  CAPNPROTO_ALWAYS_INLINE(void set(T newValue)) { value = newValue; }

private:
  T value;
};

class StructBuilder {
public:
  template <typename T>
  inline T getDataField(unsigned int offset) const;
  // Get the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.

  template <typename T>
  inline void setDataField(unsigned int offset, T value) const;
  // Set the data field value at the given offset.  Be careful to use the correct type.

  CAPNPROTO_ALWAYS_INLINE(StructBuilder getStructField(int refIndex) const);
  // Get the struct field at the given index in the reference segment.  Allocates space for the
  // struct if necessary.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder initListField(int refIndex, uint32_t size) const);
  // Allocate a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder getListField(int refIndex) const);
  // Get the already-allocated list field for the given reference index.  Returns an empty list --
  // NOT necessarily the default value -- if the field is not initialized.

  StructReader asReader() const;
  // Get a StructReader pointing at the same memory.

private:
  const StructDescriptor* descriptor;  // Descriptor for the struct.
  SegmentBuilder* segment;  // Memory segment in which the struct resides.
  void* ptr;  // Pointer to the location between the struct's data and reference segments.

  inline StructBuilder(const StructDescriptor* descriptor, SegmentBuilder* segment, void* ptr)
      : descriptor(descriptor), segment(segment), ptr(ptr) {}

  StructBuilder getStructFieldInternal(int refIndex) const;
  ListBuilder initListFieldInternal(int refIndex, uint32_t size) const;
  ListBuilder getListFieldInternal(int refIndex) const;
  // The public methods are inlined and simply wrap these "Internal" methods after doing debug
  // asserts.  This way, debugging is enabled by the caller's compiler flags rather than
  // libcapnproto's debug flags.

  friend class ListBuilder;
  friend struct WireHelpers;
};

class StructReader {
public:
  template <typename T>
  inline T getDataField(int fieldNumber, unsigned int offset) const;
  // Get the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.

  CAPNPROTO_ALWAYS_INLINE(
      StructReader getStructField(int fieldNumber, unsigned int refIndex) const);
  // Get the struct field at the given index in the reference segment, or the default value if not
  // initialized.

  CAPNPROTO_ALWAYS_INLINE(ListReader getListField(int fieldNumber, unsigned int refIndex) const);
  // Get the list field at the given index in the reference segment, or the default value if not
  // initialized.

private:
  const StructDescriptor* descriptor;  // Descriptor for the struct.
  SegmentReader* segment;  // Memory segment in which the struct resides.

  const void* ptr[2];
  // ptr[0] points to the location between the struct's data and reference segments.
  // ptr[1] points to the end of the *default* data segment.
  // We put these in an array so we can choose between them without a branch.

  int fieldCount;  // Number of fields the struct is reported to have.

  int bit0Offset;
  // A special hack:  When accessing a boolean with field number zero, pretend its offset is this
  // instead of the usual zero.  This is needed to allow a boolean list to be upgraded to a list
  // of structs.

  int recursionLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.

  inline StructReader(const StructDescriptor* descriptor, SegmentReader* segment,
                      const void* ptr, const void* defaultData, int fieldCount, int bit0Offset,
                      int recursionLimit)
      : descriptor(descriptor), segment(segment), ptr{ptr, defaultData}, fieldCount(fieldCount),
        bit0Offset(bit0Offset), recursionLimit(recursionLimit) {}

  StructReader getStructFieldInternal(int fieldNumber, unsigned int refIndex) const;
  ListReader getListFieldInternal(int fieldNumber, unsigned int refIndex) const;
  // The public methods are inlined and simply wrap these "Internal" methods after doing debug
  // asserts.  This way, debugging is enabled by the caller's compiler flags rather than
  // libcapnproto's debug flags.

  friend class ListReader;
  friend class StructBuilder;
  friend struct WireHelpers;
};

// -------------------------------------------------------------------

class ListBuilder {
public:
  inline uint32_t size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(unsigned int index) const);
  // Get the element of the given type at the given index.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataElement(unsigned int index, T value) const);
  // Set the element at the given index.  Be careful to use the correct type.

  CAPNPROTO_ALWAYS_INLINE(
      StructBuilder getStructElement(unsigned int index, uint32_t elementWordSize) const);
  // Get the struct element at the given index.  elementWordSize is the size, in 64-bit words, of
  // each element.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder initListElement(unsigned int index, uint32_t size) const);
  // Create a new list element of the given size at the given index.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder getListElement(unsigned int index) const);
  // Get the existing list element at the given index.

  ListReader asReader() const;
  // Get a ListReader pointing at the same memory.

private:
  const ListDescriptor* descriptor;  // Descriptor for the list.
  SegmentBuilder* segment;  // Memory segment in which the list resides.
  void* ptr;  // Pointer to the beginning of the list.
  uint32_t elementCount;  // Number of elements in the list.

  inline ListBuilder(const ListDescriptor* descriptor, SegmentBuilder* segment,
                     void* ptr, uint32_t size)
      : descriptor(descriptor), segment(segment), ptr(ptr), elementCount(size) {}

  StructBuilder getStructElementInternal(unsigned int index, uint32_t elementWordSize) const;
  ListBuilder initListElementInternal(unsigned int index, uint32_t size) const;
  ListBuilder getListElementInternal(unsigned int index) const;
  // The public methods are inlined and simply wrap these "Internal" methods after doing debug
  // asserts.  This way, debugging is enabled by the caller's compiler flags rather than
  // libcapnproto's debug flags.

  friend class StructBuilder;
  friend struct WireHelpers;
};

class ListReader {
public:
  inline uint32_t size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(unsigned int index) const);
  // Get the element of the given type at the given index.

  CAPNPROTO_ALWAYS_INLINE(StructReader getStructElement(unsigned int index) const);
  // Get the struct element at the given index.

  CAPNPROTO_ALWAYS_INLINE(ListReader getListElement(unsigned int index, uint32_t size) const);
  // Get the list element at the given index.

private:
  const ListDescriptor* descriptor;  // Descriptor for the list.
  SegmentReader* segment;  // Memory segment in which the list resides.

  const void* ptr;
  // Pointer to the data.  If NULL, use defaultReferences.  (Never NULL for data lists.)

  uint32_t elementCount;  // Number of elements in the list.

  unsigned int stepBits;
  // The distance between elements, in bits.  This is usually the element size, but can be larger
  // if the sender upgraded a data list to a struct list.  It will always be aligned properly for
  // the type.  Unsigned so that division by a constant power of 2 is efficient.

  int structFieldCount;
  // If the elements are structs, the number of fields in each struct.

  int recursionLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.

  inline ListReader(const ListDescriptor* descriptor, SegmentReader* segment,
                    const void* ptr, uint32_t size, int stepBits, int structFieldCount,
                    int recursionLimit)
      : descriptor(descriptor), segment(segment), ptr(ptr), elementCount(size), stepBits(stepBits),
        structFieldCount(structFieldCount), recursionLimit(recursionLimit) {}

  StructReader getStructElementInternal(unsigned int index) const;
  ListReader getListElementInternal(unsigned int index, uint32_t size) const;
  // The public methods are inlined and simply wrap these "Internal" methods after doing debug
  // asserts.  This way, debugging is enabled by the caller's compiler flags rather than
  // libcapnproto's debug flags.

  friend class StructReader;
  friend class ListBuilder;
  friend struct WireHelpers;
};

// =======================================================================================
// Internal implementation details...

template <typename T>
inline T StructBuilder::getDataField(unsigned int offset) const {
  CAPNPROTO_DEBUG_ASSERT(debug::dataFieldInRange(descriptor, offset, sizeof(T)),
      "StructBuilder::getDataField() type mismatch.");

  return reinterpret_cast<WireValue<T>*>(ptr)[-offset].get();
}

template <>
inline bool StructBuilder::getDataField<bool>(unsigned int offset) const {
  CAPNPROTO_DEBUG_ASSERT(debug::bitFieldInRange(descriptor, offset),
      "StructBuilder::getDataField<bool>() type mismatch.");
  uint8_t byte = *(reinterpret_cast<uint8_t*>(ptr) - (offset / 8) - 1);
  return (byte & (1 << (offset % 8))) != 0;
}

template <typename T>
inline void StructBuilder::setDataField(unsigned int offset, T value) const {
  CAPNPROTO_DEBUG_ASSERT(debug::dataFieldInRange(descriptor, offset, sizeof(T)),
      "StructBuilder::setDataField() type mismatch.");
  reinterpret_cast<WireValue<T>*>(ptr)[-offset].set(value);
}

template <>
inline void StructBuilder::setDataField<bool>(unsigned int offset, bool value) const {
  CAPNPROTO_DEBUG_ASSERT(debug::bitFieldInRange(descriptor, offset),
      "StructBuilder::setDataField<bool>() type mismatch.");
  uint8_t* byte = reinterpret_cast<uint8_t*>(ptr) - (offset / 8) - 1;
  *byte = (*byte & ~(1 << (offset % 8)))
        | (static_cast<uint8_t>(value) << (offset % 8));
}

inline StructBuilder StructBuilder::getStructField(int refIndex) const {
  CAPNPROTO_DEBUG_ASSERT(debug::refFieldIsStruct(descriptor, refIndex),
      "StructBuilder::getStructField() type mismatch.");
  return getStructFieldInternal(refIndex);
}

inline ListBuilder StructBuilder::initListField(int refIndex, uint32_t elementCount) const {
  CAPNPROTO_DEBUG_ASSERT(debug::refFieldIsList(descriptor, refIndex),
      "StructBuilder::initListField() type mismatch.");
  return initListFieldInternal(refIndex, elementCount);
}

inline ListBuilder StructBuilder::getListField(int refIndex) const {
  CAPNPROTO_DEBUG_ASSERT(debug::refFieldIsList(descriptor, refIndex),
      "StructBuilder::initListField() type mismatch.");
  return getListFieldInternal(refIndex);
}

// -------------------------------------------------------------------

template <typename T>
T StructReader::getDataField(int fieldNumber, unsigned int offset) const {
  CAPNPROTO_DEBUG_ASSERT(debug::fieldIsData(descriptor, fieldNumber, offset, sizeof(T) * 8),
      "StructReader::getDataField() type mismatch.");
  const void* dataPtr = ptr[fieldNumber >= fieldCount];
  return reinterpret_cast<WireValue<T>*>(dataPtr)[-offset].get();
}

template <>
inline bool StructReader::getDataField<bool>(int fieldNumber, unsigned int offset) const {
  CAPNPROTO_DEBUG_ASSERT(debug::fieldIsData(descriptor, fieldNumber, offset, 1),
      "StructReader::getDataField<bool>() type mismatch.");

  // This branch should always be optimized away when inlining.
  if (offset == 0) offset = bit0Offset;

  const void* dataPtr = ptr[fieldNumber >= fieldCount];
  uint8_t byte = *(reinterpret_cast<const uint8_t*>(dataPtr) - (offset / 8) - 1);
  return (byte & (1 << (offset % 8))) != 0;
}

inline StructReader StructReader::getStructField(int fieldNumber, unsigned int refIndex) const {
  CAPNPROTO_DEBUG_ASSERT(debug::fieldIsStruct(descriptor, fieldNumber, refIndex),
      "StructReader::getStructField() type mismatch.");
  return getStructFieldInternal(fieldNumber, refIndex);
}

inline ListReader StructReader::getListField(int fieldNumber, unsigned int refIndex) const {
  CAPNPROTO_DEBUG_ASSERT(debug::fieldIsList(descriptor, fieldNumber, refIndex),
      "StructReader::getListField() type mismatch.");
  return getListFieldInternal(fieldNumber, refIndex);
}

// -------------------------------------------------------------------

inline uint32_t ListBuilder::size() { return elementCount; }

template <typename T>
inline T ListBuilder::getDataElement(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, sizeof(T) * 8),
      "ListBuilder::getDataElement() type mismatch.");
  return reinterpret_cast<WireValue<T>*>(ptr)[index].get();
}

template <>
inline bool ListBuilder::getDataElement<bool>(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, 1),
      "ListBuilder::getDataElement<bool>() type mismatch.");
  uint8_t byte = *(reinterpret_cast<uint8_t*>(ptr) + (index / 8));
  return (byte & (1 << (index % 8))) != 0;
}

template <typename T>
inline void ListBuilder::setDataElement(unsigned int index, T value) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, sizeof(T) * 8),
      "ListBuilder::setDataElement() type mismatch.");
  reinterpret_cast<WireValue<T>*>(ptr)[index].set(value);
}

template <>
inline void ListBuilder::setDataElement<bool>(unsigned int index, bool value) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, 1),
      "ListBuilder::setDataElement<bool>() type mismatch.");
  uint8_t* byte = reinterpret_cast<uint8_t*>(ptr) + (index / 8);
  *byte = (*byte & ~(1 << (index % 8)))
        | (static_cast<uint8_t>(value) << (index % 8));
}

inline StructBuilder ListBuilder::getStructElement(
    unsigned int index, uint32_t elementWordSize) const {
  CAPNPROTO_DEBUG_ASSERT(index < elementCount, "List index out of range.");
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreStructs(descriptor, elementWordSize),
      "ListBuilder::getStructElement() type mismatch.");
  return getStructElementInternal(index, elementWordSize);
}

inline ListBuilder ListBuilder::initListElement(unsigned int index, uint32_t size) const {
  CAPNPROTO_DEBUG_ASSERT(index < elementCount, "List index out of range.");
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreLists(descriptor),
      "ListBuilder::initListElement() type mismatch.");
  return initListElementInternal(index, size);
}

inline ListBuilder ListBuilder::getListElement(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(index < elementCount, "List index out of range.");
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreLists(descriptor),
      "ListBuilder::getListElement() type mismatch.");
  return getListElementInternal(index);
}

// -------------------------------------------------------------------

inline uint32_t ListReader::size() { return elementCount; }

template <typename T>
inline T ListReader::getDataElement(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, sizeof(T) * 8),
      "ListReader::getDataElement() type mismatch.");
  return *reinterpret_cast<const T*>(
      reinterpret_cast<const uint8_t*>(ptr) + index * (stepBits / 8));
}

template <>
inline bool ListReader::getDataElement<bool>(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreData(descriptor, 1),
      "ListReader::getDataElement<bool>() type mismatch.");
  unsigned int bitIndex = index * stepBits;
  uint8_t byte = *(reinterpret_cast<const uint8_t*>(ptr) + (bitIndex / 8));
  return (byte & (1 << (bitIndex % 8))) != 0;
}

inline StructReader ListReader::getStructElement(unsigned int index) const {
  CAPNPROTO_DEBUG_ASSERT(index < elementCount, "List index out of range.");
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreStructs(descriptor),
      "ListReader::getStructElement() type mismatch.");
  return getStructElementInternal(index);
}

inline ListReader ListReader::getListElement(unsigned int index, uint32_t size) const {
  CAPNPROTO_DEBUG_ASSERT(index < elementCount, "List index out of range.");
  CAPNPROTO_DEBUG_ASSERT(debug::elementsAreLists(descriptor),
      "ListReader::getListElement() type mismatch.");
  return getListElementInternal(index, size);
}

}  // namespace internal
}  // namespace capnproto

#endif  // CAPNPROTO_WIRE_FORMAT_H_
