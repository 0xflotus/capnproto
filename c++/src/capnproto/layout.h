// Copyright (c) 2013, Kenton Varda <temporal@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is NOT intended for use by clients, except in generated code.
//
// This file defines low-level, non-type-safe classes for traversing the Cap'n Proto memory layout
// (which is also its wire format).  Code generated by the Cap'n Proto compiler uses these classes,
// as does other parts of the Cap'n proto library which provide a higher-level interface for
// dynamic introspection.

#ifdef __CDT_PARSER__
// Eclipse keeps thinking this is pre-defined for no apparent reason.
#undef CAPNPROTO_LAYOUT_H_
#endif

#ifndef CAPNPROTO_LAYOUT_H_
#define CAPNPROTO_LAYOUT_H_

#include "macros.h"
#include "type-safety.h"
#include "blob.h"

namespace capnproto {
namespace internal {

class StructBuilder;
class StructReader;
class ListBuilder;
class ListReader;
struct WireReference;
struct WireHelpers;
class SegmentReader;
class SegmentBuilder;

class FieldDescriptor;
typedef Id<uint8_t, FieldDescriptor> FieldNumber;
enum class FieldSize: uint8_t;

enum class FieldSize: uint8_t {
  // TODO:  Rename to FieldLayout or maybe ValueLayout.

  VOID = 0,
  BIT = 1,
  BYTE = 2,
  TWO_BYTES = 3,
  FOUR_BYTES = 4,
  EIGHT_BYTES = 5,

  REFERENCE = 6,  // Indicates that the field lives in the reference segment, not the data segment.

  INLINE_COMPOSITE = 7
  // A composite type of fixed width.  This serves two purposes:
  // 1) For lists of composite types where all the elements would have the exact same width,
  //    allocating a list of references which in turn point at the elements would waste space.  We
  //    can avoid a layer of indirection by placing all the elements in a flat sequence, and only
  //    indicating the element properties (e.g. field count for structs) once.
  //
  //    Specifically, a list reference indicating INLINE_COMPOSITE element size actually points to
  //    a "tag" describing one element.  This tag is formatted like a wire reference, but the
  //    "offset" instead stores the element count of the list.  The flat list of elements appears
  //    immediately after the tag.  In the list reference itself, the element count is replaced with
  //    a word count for the whole list (excluding tag).  This allows the tag and elements to be
  //    precached in a single step rather than two sequential steps.
  //
  //    It is NOT intended to be possible to substitute an INLINE_COMPOSITE list for a REFERENCE
  //    list or vice-versa without breaking recipients.  Recipients expect one or the other
  //    depending on the message definition.
  //
  //    However, it IS allowed to substitute an INLINE_COMPOSITE list -- specifically, of structs --
  //    when a list was expected, or vice versa, with the assumption that the first field of the
  //    struct (field number zero) correspond to the element type.  This allows a list of
  //    primitives to be upgraded to a list of structs, avoiding the need to use parallel arrays
  //    when you realize that you need to attach some extra information to each element of some
  //    primitive list.
  //
  // 2) For struct fields of composite types where the field's total size is known at compile time,
  //    we can embed the field directly into the parent struct to avoid indirection through a
  //    reference.  However, this means that the field size can never change -- e.g. if it is a
  //    struct, new fields cannot be added to it.  The field's struct type is therefore required to
  //    be declared "inline" with a fixed width.
};

typedef decltype(BITS / ELEMENTS) BitsPerElement;
typedef decltype(BYTES / ELEMENTS) BytesPerElement;

namespace internal {
  static constexpr BitsPerElement BITS_PER_ELEMENT_TABLE[8] = {
      0 * BITS / ELEMENTS,
      1 * BITS / ELEMENTS,
      8 * BITS / ELEMENTS,
      16 * BITS / ELEMENTS,
      32 * BITS / ELEMENTS,
      64 * BITS / ELEMENTS,
      64 * BITS / ELEMENTS,
      0 * BITS / ELEMENTS
  };
}

inline constexpr BitsPerElement bitsPerElement(FieldSize size) {
  return internal::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];
}

inline constexpr BytesPerElement bytesPerElement(FieldSize size) {
  // BIT gets rounded down to zero bytes.  This is OK because bytesPerElement() is only used in
  // cases where this doesn't matter, e.g. for computing stepBytes which is ignored by bit ops
  // anyway.
  return bitsPerElement(size) / BITS_PER_BYTE;
}

template <int wordCount>
union AlignedData {
  // Useful for declaring static constant data blobs as an array of bytes, but forcing those
  // bytes to be word-aligned.

  uint8_t bytes[wordCount * sizeof(word)];
  word words[wordCount];
};

struct StructSize {
  WordCount16 data;
  WireReferenceCount16 pointers;

  ByteCount32 dataBytes;
  // Number of bytes in the data section.  Must be data * 8 except when data == 1 in which case
  // this can be 1, 2, 4, or 8.

  inline constexpr WordCount total() const { return data + pointers * WORDS_PER_REFERENCE; }

  StructSize() = default;
  inline constexpr StructSize(WordCount data, WireReferenceCount pointers, ByteCount dataBytes)
      : data(data), pointers(pointers), dataBytes(dataBytes) {}
};

template <typename T>
class IsEnum {
  // Detects whether a primitive value is an enum.

  typedef char no;
  typedef long yes;

  static no test(int i);
  static yes test(...);

public:
  static constexpr bool value = sizeof(test(T())) == sizeof(yes);
};

// -------------------------------------------------------------------
// Masking of default values

template <typename T, bool isEnum = IsEnum<T>::value> struct MaskType { typedef T Type; };
template <typename T> struct MaskType<T, false> { typedef T Type; };
template <typename T> struct MaskType<T, true> { typedef uint16_t Type; };
template <> struct MaskType<float, false> { typedef uint32_t Type; };
template <> struct MaskType<double, false> { typedef uint64_t Type; };

template <typename T>
CAPNPROTO_ALWAYS_INLINE(
    typename MaskType<T>::Type mask(T value, typename MaskType<T>::Type mask));
template <typename T>
CAPNPROTO_ALWAYS_INLINE(
    T unmask(typename MaskType<T>::Type value, typename MaskType<T>::Type mask));

template <typename T>
inline typename MaskType<T>::Type mask(T value, typename MaskType<T>::Type mask) {
  return static_cast<typename MaskType<T>::Type>(value) ^ mask;
}

template <>
inline uint32_t mask<float>(float value, uint32_t mask) {
  uint32_t i;
  static_assert(sizeof(i) == sizeof(value), "float is not 32 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <>
inline uint64_t mask<double>(double value, uint64_t mask) {
  uint64_t i;
  static_assert(sizeof(i) == sizeof(value), "double is not 64 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <typename T>
inline T unmask(typename MaskType<T>::Type value, typename MaskType<T>::Type mask) {
  return static_cast<T>(value ^ mask);
}

template <>
inline float unmask<float>(uint32_t value, uint32_t mask) {
  value ^= mask;
  float result;
  static_assert(sizeof(result) == sizeof(value), "float is not 32 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}

template <>
inline double unmask<double>(uint64_t value, uint64_t mask) {
  value ^= mask;
  double result;
  static_assert(sizeof(result) == sizeof(value), "double is not 64 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}

// -------------------------------------------------------------------

template <typename T>
class WireValue {
  // Wraps a primitive value as it appears on the wire.  Namely, values are little-endian on the
  // wire, because little-endian is the most common endianness in modern CPUs.
  //
  // TODO:  On big-endian systems, inject byte-swapping here.  Most big-endian CPUs implement
  //   dedicated instructions for this, so use those rather than writing a bunch of shifts and
  //   masks.  Note that GCC has e.g. __builtin__bswap32() for this.
  //
  // Note:  In general, code that depends cares about byte ordering is bad.  See:
  //     http://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html
  //   Cap'n Proto is special because it is essentially doing compiler-like things, fussing over
  //   allocation and layout of memory, in order to squeeze out every last drop of performance.

public:
  WireValue() = default;
  CAPNPROTO_ALWAYS_INLINE(WireValue(T value)): value(value) {}

  CAPNPROTO_ALWAYS_INLINE(T get() const) { return value; }
  CAPNPROTO_ALWAYS_INLINE(void set(T newValue)) { value = newValue; }

private:
  T value;
};

class StructBuilder {
public:
  inline StructBuilder(): segment(nullptr), data(nullptr), references(nullptr) {}

  static StructBuilder initRoot(SegmentBuilder* segment, word* location, StructSize size);
  static StructBuilder getRoot(SegmentBuilder* segment, word* location, StructSize size);

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(ElementCount offset) const);
  // Gets the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(
      ElementCount offset, typename MaskType<T>::Type mask) const);
  // Like getDataField() but applies the given XOR mask to the data on load.  Used for reading
  // fields with non-zero default values.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataField(
      ElementCount offset, typename NoInfer<T>::Type value) const);
  // Sets the data field value at the given offset.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataField(
      ElementCount offset, typename NoInfer<T>::Type value, typename MaskType<T>::Type mask) const);
  // Like setDataField() but applies the given XOR mask before storing.  Used for writing fields
  // with non-zero default values.

  StructBuilder initStructField(WireReferenceCount refIndex, StructSize size) const;
  // Initializes the struct field at the given index in the reference segment.  If it is already
  // initialized, the previous value is discarded or overwritten.  The struct is initialized to
  // the type's default state (all-zero).  Use getStructField() if you want the struct to be
  // initialized as a copy of the field's default value (which may have non-null references).

  StructBuilder getStructField(WireReferenceCount refIndex, StructSize size,
                               const word* defaultValue) const;
  // Gets the struct field at the given index in the reference segment.  If the field is not already
  // initialized, it is initialized as a deep copy of the given default value (a trusted message),
  // or to the empty state if defaultValue is nullptr.

  CAPNPROTO_ALWAYS_INLINE(StructBuilder initInlineStructField(
      ByteCount dataOffset, ByteCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const);
  // Initialize an inlined struct field, given the position and size of the data and pointer
  // sections.

  CAPNPROTO_ALWAYS_INLINE(StructBuilder getInlineStructField(
      ByteCount dataOffset, ByteCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const);
  // Gets an inlined struct field, given the position and size of the data and pointer sections.

  ListBuilder initListField(WireReferenceCount refIndex, FieldSize elementSize,
                            ElementCount elementCount) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  All elements are initialized to zero.

  ListBuilder initStructListField(WireReferenceCount refIndex, ElementCount elementCount,
                                  StructSize size) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  Each element is initialized to its empty state.

  ListBuilder getListField(WireReferenceCount refIndex, const word* defaultValue) const;
  // Gets the already-allocated list field for the given reference index.  If the list is not
  // already allocated, it is allocated as a deep copy of the given default value (a trusted
  // message).  If the default value is null, an empty list is used.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder initInlineDataListField(
      ByteCount offset, ByteCount inlineSize,
      ElementCount elementCount, FieldSize elementSize) const);
  // Initialize an inline list field.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder initInlinePointerListField(
      WireReferenceCount offset, WireReferenceCount inlineSize,
      ElementCount elementCount) const);
  // Initialize an inline list field.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder initInlineStructListField(
      ByteCount dataOffset, WireReferenceCount ptrOffset, ElementCount elementCount,
      StructSize elementSize) const);
  // Initialize an inline struct list field.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder getInlineDataListField(
      ByteCount offset, ElementCount elementCount, FieldSize elementSize) const);
  // Get an already-initialized inline list field.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder getInlinePointerListField(
      WireReferenceCount offset, ElementCount elementCount) const);
  // Get an already-initialized inline list field.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder getInlineStructListField(
      ByteCount dataOffset, WireReferenceCount ptrOffset, ElementCount elementCount,
      StructSize elementSize) const);
  // Get an already-initialized inline struct list field.

  Text::Builder initTextField(WireReferenceCount refIndex, ByteCount size) const;
  // Initialize the text field to the given size in bytes (not including NUL terminator) and return
  // a Text::Builder which can be used to fill in the content.

  void setTextField(WireReferenceCount refIndex, Text::Reader value) const;
  // Set the text field to a copy of the given text.

  Text::Builder getTextField(WireReferenceCount refIndex,
                             const void* defaultValue, ByteCount defaultSize) const;
  // Get the text field.  If it is not initialized, initialize it to a copy of the given default.

  Data::Builder initDataField(WireReferenceCount refIndex, ByteCount size) const;
  void setDataField(WireReferenceCount refIndex, Data::Reader value) const;
  Data::Builder getDataField(WireReferenceCount refIndex,
                             const void* defaultValue, ByteCount defaultSize) const;
  // Same as *Text*, but for data blobs.

  CAPNPROTO_ALWAYS_INLINE(Data::Builder getInlineDataField(
      ByteCount offset, ByteCount size) const);
  CAPNPROTO_ALWAYS_INLINE(void setInlineDataField(
      ByteCount offset, ByteCount size, Data::Reader value) const);
  CAPNPROTO_ALWAYS_INLINE(Data::Builder initInlineDataField(
      ByteCount offset, ByteCount size) const);
  // For InlineData.

  StructReader asReader() const;
  // Gets a StructReader pointing at the same memory.

  WireReferenceCount getReferenceCount() { return referenceCount; }

private:
  SegmentBuilder* segment;     // Memory segment in which the struct resides.
  void* data;                  // Pointer to the encoded data.
  WireReference* references;   // Pointer to the encoded references.

  WireReferenceCount16 referenceCount;
  // Size of the pointer segment, available only for the sake of computing size of List(Inline(T)).

  inline StructBuilder(SegmentBuilder* segment, void* data, WireReference* references,
                       WireReferenceCount referenceCount)
      : segment(segment), data(data), references(references),
        referenceCount(referenceCount) {}

  friend class ListBuilder;
  friend struct WireHelpers;
};

class StructReader {
public:
  inline StructReader()
      : segment(nullptr), data(nullptr), references(nullptr), dataSize(0),
        referenceCount(0), nestingLimit(0) {}

  static StructReader readRootTrusted(const word* location);
  static StructReader readRoot(const word* location, SegmentReader* segment, int nestingLimit);
  static StructReader readEmpty();

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(ElementCount offset) const);
  // Get the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.  Returns zero if the offset is past the
  // end of the struct's data segment.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(
      T getDataField(ElementCount offset, typename MaskType<T>::Type mask) const);
  // Like getDataField(offset), but applies the given XOR mask to the result.  Used for reading
  // fields with non-zero default values.

  StructReader getStructField(WireReferenceCount refIndex, const word* defaultValue) const;
  // Get the struct field at the given index in the reference segment, or the default value if not
  // initialized.  defaultValue will be interpreted as a trusted message -- it must point at a
  // struct reference, which in turn points at the struct value.  The default value is allowed to
  // be null, in which case an empty struct is used.

  StructReader getInlineStructField(
      ByteCount dataOffset, ByteCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const;
  // Gets an inlined struct field, given the position and size of the data and pointer sections.

  ListReader getListField(WireReferenceCount refIndex, FieldSize expectedElementSize,
                          const word* defaultValue) const;
  // Get the list field at the given index in the reference segment, or the default value if not
  // initialized.  The default value is allowed to be null, in which case an empty list is used.

  ListReader getInlineDataListField(
      ByteCount offset, ElementCount elementCount, FieldSize elementSize) const;
  // Get an inline list field.

  ListReader getInlinePointerListField(
      WireReferenceCount offset, ElementCount elementCount) const;
  // Get an inline list field.

  ListReader getInlineStructListField(
      ByteCount dataOffset, WireReferenceCount ptrOffset, ElementCount elementCount,
      StructSize elementSize) const;
  // Get an inline struct list field.

  Text::Reader getTextField(WireReferenceCount refIndex,
                            const void* defaultValue, ByteCount defaultSize) const;
  // Gets the text field, or the given default value if not initialized.

  Data::Reader getDataField(WireReferenceCount refIndex,
                            const void* defaultValue, ByteCount defaultSize) const;
  // Gets the data field, or the given default value if not initialized.

  Data::Reader getInlineDataField(ByteCount offset, ByteCount size) const;
  // Gets the inline data field.

  WireReferenceCount getReferenceCount() { return referenceCount; }

private:
  SegmentReader* segment;  // Memory segment in which the struct resides.

  const void* data;
  const WireReference* references;

  ByteCount32 dataSize;                 // Size of data segment.
  WireReferenceCount16 referenceCount;  // Size of the reference segment.

  int nestingLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.
  // TODO:  Limit to 8 bits for better alignment?

  inline StructReader(SegmentReader* segment, const void* data, const WireReference* references,
                      ByteCount dataSize, WireReferenceCount referenceCount, int nestingLimit)
      : segment(segment), data(data), references(references),
        dataSize(dataSize), referenceCount(referenceCount),
        nestingLimit(nestingLimit) {}

  friend class ListReader;
  friend class StructBuilder;
  friend struct WireHelpers;
};

// -------------------------------------------------------------------

class ListBuilder {
public:
  inline ListBuilder()
      : segment(nullptr), data(nullptr), pointers(nullptr), elementCount(0 * ELEMENTS),
        stepBytes(0 * BYTES / ELEMENTS), stepPointers(0 * REFERENCES / ELEMENTS) {}

  inline ElementCount size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(ElementCount index) const);
  // Get the element of the given type at the given index.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataElement(
      ElementCount index, typename NoInfer<T>::Type value) const);
  // Set the element at the given index.

  StructBuilder getStructElement(ElementCount index, StructSize elementSize) const;
  // Get the struct element at the given index.

  ListBuilder initListElement(
      ElementCount index, FieldSize elementSize, ElementCount elementCount) const;
  // Create a new list element of the given size at the given index.  All elements are initialized
  // to zero.

  ListBuilder initStructListElement(ElementCount index, ElementCount elementCount,
                                    StructSize size) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  Each element is initialized to its empty state.

  ListBuilder getListElement(ElementCount index) const;
  // Get the existing list element at the given index.  Returns an empty list if the element is
  // not initialized.

  CAPNPROTO_ALWAYS_INLINE(ListBuilder slice(ElementCount start, ElementCount length) const);
  // Get a list pointing at a slice of this list.  WARNING:  The second parameter is a length, not
  // an end index, because this is what is most convenient at the only call site.

  Text::Builder initTextElement(ElementCount index, ByteCount size) const;
  // Initialize the text element to the given size in bytes (not including NUL terminator) and
  // return a Text::Builder which can be used to fill in the content.

  void setTextElement(ElementCount index, Text::Reader value) const;
  // Set the text element to a copy of the given text.

  Text::Builder getTextElement(ElementCount index) const;
  // Get the text element.  If it is not initialized, returns an empty Text::Builder.

  Data::Builder initDataElement(ElementCount index, ByteCount size) const;
  void setDataElement(ElementCount index, Data::Reader value) const;
  Data::Builder getDataElement(ElementCount index) const;
  // Like *Text*() but for Data.

  ListReader asReader(FieldSize elementSize) const;
  // Get a ListReader pointing at the same memory.  Use this version only for non-struct lists.

  ListReader asReader(StructSize elementSize) const;
  // Get a ListReader pointing at the same memory.  Use this version only for struct lists.

private:
  SegmentBuilder* segment;  // Memory segment in which the list resides.

  void* data;
  WireReference* pointers;
  // Pointers to list content.

  ElementCount elementCount;  // Number of elements in the list.

  decltype(BYTES / ELEMENTS) stepBytes;
  decltype(REFERENCES / ELEMENTS) stepPointers;
  // The distance between elements.  Can be tricky e.g. for inlined struct lists.
  // Bit lists ignore stepBytes -- they are always tightly-packed.

  inline ListBuilder(SegmentBuilder* segment, void* data, WireReference* pointers,
                     decltype(BYTES / ELEMENTS) stepBytes,
                     decltype(REFERENCES / ELEMENTS) stepPointers, ElementCount size)
      : segment(segment), data(data), pointers(pointers), elementCount(size),
        stepBytes(stepBytes), stepPointers(stepPointers) {}

  friend class StructBuilder;
  friend struct WireHelpers;
};

class ListReader {
public:
  inline ListReader()
      : segment(nullptr), data(nullptr), pointers(nullptr), elementCount(0),
        stepBytes(0 * BYTES / ELEMENTS), stepPointers(0 * REFERENCES / ELEMENTS),
        structDataSize(0), structReferenceCount(0), nestingLimit(0) {}

  ListReader(ElementCount elementCount);
  // Constructs a ListReader representing a list where all elements are zero.  Intended to be used
  // only for inlined lists that are out-of-bounds in the parent struct.

  inline ElementCount size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(ElementCount index) const);
  // Get the element of the given type at the given index.

  StructReader getStructElement(ElementCount index) const;
  // Get the struct element at the given index.

  ListReader getListElement(ElementCount index, FieldSize expectedElementSize) const;
  // Get the list element at the given index.

  CAPNPROTO_ALWAYS_INLINE(ListReader slice(ElementCount start, ElementCount length) const);
  // Get a list pointing at a slice of this list.  WARNING:  The second parameter is a length, not
  // an end index, because this is what is most convenient at the only call site.

  Text::Reader getTextElement(ElementCount index) const;
  // Get the text element.  If it is not initialized, returns an empty Text::Reader.

  Data::Reader getDataElement(ElementCount index) const;
  // Get the data element.  If it is not initialized, returns an empty Data::Reader.

private:
  SegmentReader* segment;  // Memory segment in which the list resides.

  const void* data;
  const WireReference* pointers;
  // Pointers to list content.

  ElementCount elementCount;  // Number of elements in the list.

  decltype(BYTES / ELEMENTS) stepBytes;
  decltype(REFERENCES / ELEMENTS) stepPointers;
  // The distance between elements.  Can be tricky e.g. for inlined struct lists.
  // Bit lists ignore stepBytes -- they are always tightly-packed.

  ByteCount structDataSize;
  WireReferenceCount structReferenceCount;
  // If the elements are structs, the properties of the struct.

  int nestingLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.

  inline ListReader(SegmentReader* segment, const void* data, const WireReference* pointers,
                    ElementCount elementCount, decltype(BYTES / ELEMENTS) stepBytes,
                    decltype(REFERENCES / ELEMENTS) stepPointers, int nestingLimit)
      : segment(segment), data(data), pointers(pointers), elementCount(elementCount),
        stepBytes(stepBytes), stepPointers(stepPointers), structDataSize(0),
        structReferenceCount(0), nestingLimit(nestingLimit) {}
  inline ListReader(SegmentReader* segment, const void* data, const WireReference* pointers,
                    ElementCount elementCount, decltype(BYTES / ELEMENTS) stepBytes,
                    decltype(REFERENCES / ELEMENTS) stepPointers, ByteCount structDataSize,
                    WireReferenceCount structReferenceCount, int nestingLimit)
      : segment(segment), data(data), pointers(pointers), elementCount(elementCount),
        stepBytes(stepBytes), stepPointers(stepPointers), structDataSize(structDataSize),
        structReferenceCount(structReferenceCount), nestingLimit(nestingLimit) {}

  friend class StructReader;
  friend class ListBuilder;
  friend struct WireHelpers;
};

// =======================================================================================
// Internal implementation details...

template <typename T>
inline T StructBuilder::getDataField(ElementCount offset) const {
  return reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].get();
}

template <>
inline bool StructBuilder::getDataField<bool>(ElementCount offset) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void StructBuilder::getDataField<Void>(ElementCount offset) const {
  return Void::VOID;
}

template <typename T>
inline T StructBuilder::getDataField(ElementCount offset, typename MaskType<T>::Type mask) const {
  return unmask<T>(getDataField<typename MaskType<T>::Type>(offset), mask);
}

template <typename T>
inline void StructBuilder::setDataField(
    ElementCount offset, typename NoInfer<T>::Type value) const {
  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);
}

template <>
inline void StructBuilder::setDataField<bool>(ElementCount offset, bool value) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  uint bitnum = boffset % BITS_PER_BYTE / BITS;
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << bitnum))
                                 | (static_cast<uint8_t>(value) << bitnum);
}

template <>
inline void StructBuilder::setDataField<Void>(ElementCount offset, Void value) const {}

template <typename T>
inline void StructBuilder::setDataField(
    ElementCount offset, typename NoInfer<T>::Type value, typename MaskType<T>::Type m) const {
  setDataField<typename MaskType<T>::Type>(offset, mask<T>(value, m));
}

inline StructBuilder StructBuilder::initInlineStructField(
    ByteCount dataOffset, ByteCount inlineDataSize,
    WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const {
  memset(reinterpret_cast<byte*>(data) + dataOffset, 0, inlineDataSize / BYTES);
  memset(reinterpret_cast<word*>(references) + refIndex * WORDS_PER_REFERENCE,
         0, inlineRefCount * WORDS_PER_REFERENCE * BYTES_PER_WORD / BYTES);
  return getInlineStructField(dataOffset, inlineDataSize, refIndex, inlineRefCount);
}

inline StructBuilder StructBuilder::getInlineStructField(
    ByteCount dataOffset, ByteCount inlineDataSize,
    WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const {
  return StructBuilder(
      segment, reinterpret_cast<byte*>(data) + dataOffset,
      // WireReference is incomplete here so we have to cast around...  Bah.
      reinterpret_cast<WireReference*>(
          reinterpret_cast<word*>(references) + refIndex * WORDS_PER_REFERENCE),
      inlineRefCount);
}

inline ListBuilder StructBuilder::initInlineDataListField(
    ByteCount offset, ByteCount inlineSize,
    ElementCount elementCount, FieldSize elementSize) const {
  memset(reinterpret_cast<byte*>(data) + offset, 0, inlineSize / BYTES);
  return getInlineDataListField(offset, elementCount, elementSize);
}

inline ListBuilder StructBuilder::initInlinePointerListField(
    WireReferenceCount offset, WireReferenceCount inlineSize,
    ElementCount elementCount) const {
  memset(reinterpret_cast<word*>(references) + offset * WORDS_PER_REFERENCE, 0,
         inlineSize * BYTES_PER_REFERENCE / BYTES);
  return getInlinePointerListField(offset, elementCount);
}

inline ListBuilder StructBuilder::initInlineStructListField(
    ByteCount dataOffset, WireReferenceCount ptrOffset, ElementCount elementCount,
    StructSize elementSize) const {
  memset(reinterpret_cast<byte*>(data) + dataOffset, 0,
         elementSize.dataBytes / BYTES);
  memset(reinterpret_cast<word*>(references) + ptrOffset * WORDS_PER_REFERENCE, 0,
         elementSize.pointers * BYTES_PER_REFERENCE / BYTES);
  return getInlineStructListField(dataOffset, ptrOffset, elementCount, elementSize);
}

inline ListBuilder StructBuilder::getInlineDataListField(
    ByteCount offset, ElementCount elementCount, FieldSize elementSize) const {
  return ListBuilder(
      segment, reinterpret_cast<byte*>(data) + offset, nullptr,
      bytesPerElement(elementSize), 0 * REFERENCES / ELEMENTS, elementCount);
}

inline ListBuilder StructBuilder::getInlinePointerListField(
    WireReferenceCount offset, ElementCount elementCount) const {
  return ListBuilder(
      segment, nullptr,
      reinterpret_cast<WireReference*>(
          reinterpret_cast<word*>(references) + offset * WORDS_PER_REFERENCE),
      0 * BYTES / ELEMENTS, 1 * REFERENCES / ELEMENTS, elementCount);
}

inline ListBuilder StructBuilder::getInlineStructListField(
    ByteCount dataOffset, WireReferenceCount ptrOffset, ElementCount elementCount,
    StructSize elementSize) const {
  return ListBuilder(
      segment, reinterpret_cast<byte*>(data) + dataOffset,
      reinterpret_cast<WireReference*>(
          reinterpret_cast<word*>(references) + ptrOffset * WORDS_PER_REFERENCE),
      elementSize.dataBytes / ELEMENTS, elementSize.pointers / ELEMENTS,
      elementCount);
}

inline Data::Builder StructBuilder::getInlineDataField(
    ByteCount offset, ByteCount size) const {
  return Data::Builder(
      reinterpret_cast<char*>(reinterpret_cast<byte*>(data) + offset), size / BYTES);
}
inline void StructBuilder::setInlineDataField(
    ByteCount offset, ByteCount size, Data::Reader value) const {
  getInlineDataField(offset, size).copyFrom(value);
}
inline Data::Builder StructBuilder::initInlineDataField(
    ByteCount offset, ByteCount size) const {
  byte* ptr = reinterpret_cast<byte*>(data) + offset;
  memset(ptr, 0, size / BYTES);
  return Data::Builder(reinterpret_cast<char*>(ptr), size / BYTES);
}

// -------------------------------------------------------------------

template <typename T>
T StructReader::getDataField(ElementCount offset) const {
  if ((offset + 1 * ELEMENTS) * capnproto::bytesPerElement<T>() <= dataSize) {
    return reinterpret_cast<const WireValue<T>*>(data)[offset / ELEMENTS].get();
  } else {
    return static_cast<T>(0);
  }
}

template <>
inline bool StructReader::getDataField<bool>(ElementCount offset) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);
  if (boffset < dataSize * BITS_PER_BYTE) {
    const byte* b = reinterpret_cast<const byte*>(data) + boffset / BITS_PER_BYTE;
    return (*reinterpret_cast<const uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;
  } else {
    return false;
  }
}

template <>
inline Void StructReader::getDataField<Void>(ElementCount offset) const {
  return Void::VOID;
}

template <typename T>
T StructReader::getDataField(ElementCount offset, typename MaskType<T>::Type mask) const {
  return unmask<T>(getDataField<typename MaskType<T>::Type>(offset), mask);
}

// -------------------------------------------------------------------

inline ElementCount ListBuilder::size() { return elementCount; }

template <typename T>
inline T ListBuilder::getDataElement(ElementCount index) const {
  return reinterpret_cast<WireValue<T>*>(
      reinterpret_cast<byte*>(data) + index * stepBytes)->get();
}

template <>
inline bool ListBuilder::getDataElement<bool>(ElementCount index) const {
  // Ignore stepBytes for bit lists because bit lists cannot be upgraded to struct lists.
  BitCount bindex = index * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void ListBuilder::getDataElement<Void>(ElementCount index) const {
  return Void::VOID;
}

template <typename T>
inline void ListBuilder::setDataElement(ElementCount index, typename NoInfer<T>::Type value) const {
  reinterpret_cast<WireValue<T>*>(
      reinterpret_cast<byte*>(data) + index * stepBytes)->set(value);
}

template <>
inline void ListBuilder::setDataElement<bool>(ElementCount index, bool value) const {
  // Ignore stepBytes for bit lists because bit lists cannot be upgraded to struct lists.
  BitCount bindex = index * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + bindex / BITS_PER_BYTE;
  uint bitnum = bindex % BITS_PER_BYTE / BITS;
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << bitnum))
                                 | (static_cast<uint8_t>(value) << bitnum);
}

template <>
inline void ListBuilder::setDataElement<Void>(ElementCount index, Void value) const {}

inline ListBuilder ListBuilder::slice(ElementCount start, ElementCount length) const {
  return ListBuilder(segment,
      reinterpret_cast<byte*>(data) + start * stepBytes,
      reinterpret_cast<WireReference*>(
          reinterpret_cast<word*>(pointers) + start * stepPointers * WORDS_PER_REFERENCE),
      stepBytes, stepPointers, length);
}

// -------------------------------------------------------------------

inline ElementCount ListReader::size() { return elementCount; }

template <typename T>
inline T ListReader::getDataElement(ElementCount index) const {
  return reinterpret_cast<const WireValue<T>*>(
      reinterpret_cast<const byte*>(data) + index * stepBytes)->get();
}

template <>
inline bool ListReader::getDataElement<bool>(ElementCount index) const {
  // Ignore stepBytes for bit lists because bit lists cannot be upgraded to struct lists.
  BitCount bindex = index * (1 * BITS / ELEMENTS);
  const byte* b = reinterpret_cast<const byte*>(data) + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<const uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void ListReader::getDataElement<Void>(ElementCount index) const {
  return Void::VOID;
}

inline ListReader ListReader::slice(ElementCount start, ElementCount length) const {
  return ListReader(segment,
      reinterpret_cast<const byte*>(data) + start * stepBytes,
      reinterpret_cast<const WireReference*>(
          reinterpret_cast<const word*>(pointers) + start * stepPointers * WORDS_PER_REFERENCE),
      length, stepBytes, stepPointers, structDataSize, structReferenceCount, nestingLimit);
}

}  // namespace internal
}  // namespace capnproto

#endif  // CAPNPROTO_LAYOUT_H_
