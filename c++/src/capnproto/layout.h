// Copyright (c) 2013, Kenton Varda <temporal@gmail.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is NOT intended for use by clients, except in generated code.
//
// This file defines low-level, non-type-safe classes for traversing the Cap'n Proto memory layout
// (which is also its wire format).  Code generated by the Cap'n Proto compiler uses these classes,
// as does other parts of the Cap'n proto library which provide a higher-level interface for
// dynamic introspection.

#ifdef __CDT_PARSER__
// Eclipse keeps thinking this is pre-defined for no apparent reason.
#undef CAPNPROTO_LAYOUT_H_
#endif

#ifndef CAPNPROTO_LAYOUT_H_
#define CAPNPROTO_LAYOUT_H_

#include "macros.h"
#include "type-safety.h"
#include "blob.h"

namespace capnproto {
namespace internal {

class StructBuilder;
class StructReader;
class ListBuilder;
class ListReader;
struct WireReference;
struct WireHelpers;
class SegmentReader;
class SegmentBuilder;

class FieldDescriptor;
typedef Id<uint8_t, FieldDescriptor> FieldNumber;
enum class FieldSize: uint8_t;

enum class FieldSize: uint8_t {
  // TODO:  Rename to FieldLayout or maybe ValueLayout.

  VOID = 0,
  BIT = 1,
  BYTE = 2,
  TWO_BYTES = 3,
  FOUR_BYTES = 4,
  EIGHT_BYTES = 5,

  REFERENCE = 6,  // Indicates that the field lives in the reference segment, not the data segment.

  INLINE_COMPOSITE = 7
  // A composite type of fixed width.  This serves two purposes:
  // 1) For lists of composite types where all the elements would have the exact same width,
  //    allocating a list of references which in turn point at the elements would waste space.  We
  //    can avoid a layer of indirection by placing all the elements in a flat sequence, and only
  //    indicating the element properties (e.g. field count for structs) once.
  //
  //    Specifically, a list reference indicating INLINE_COMPOSITE element size actually points to
  //    a "tag" describing one element.  This tag is formatted like a wire reference, but the
  //    "offset" instead stores the element count of the list.  The flat list of elements appears
  //    immediately after the tag.  In the list reference itself, the element count is replaced with
  //    a word count for the whole list (excluding tag).  This allows the tag and elements to be
  //    precached in a single step rather than two sequential steps.
  //
  //    It is NOT intended to be possible to substitute an INLINE_COMPOSITE list for a REFERENCE
  //    list or vice-versa without breaking recipients.  Recipients expect one or the other
  //    depending on the message definition.
  //
  //    However, it IS allowed to substitute an INLINE_COMPOSITE list -- specifically, of structs --
  //    when a list was expected, or vice versa, with the assumption that the first field of the
  //    struct (field number zero) correspond to the element type.  This allows a list of
  //    primitives to be upgraded to a list of structs, avoiding the need to use parallel arrays
  //    when you realize that you need to attach some extra information to each element of some
  //    primitive list.
  //
  // 2) For struct fields of composite types where the field's total size is known at compile time,
  //    we can embed the field directly into the parent struct to avoid indirection through a
  //    reference.  However, this means that the field size can never change -- e.g. if it is a
  //    struct, new fields cannot be added to it.  The field's struct type is therefore required to
  //    be declared "inline" with a fixed width.
};

typedef decltype(BITS / ELEMENTS) BitsPerElement;

namespace internal {
  static constexpr BitsPerElement BITS_PER_ELEMENT_TABLE[8] = {
      0 * BITS / ELEMENTS,
      1 * BITS / ELEMENTS,
      8 * BITS / ELEMENTS,
      16 * BITS / ELEMENTS,
      32 * BITS / ELEMENTS,
      64 * BITS / ELEMENTS,
      64 * BITS / ELEMENTS,
      0 * BITS / ELEMENTS
  };
}

inline constexpr BitsPerElement bitsPerElement(FieldSize size) {
  return internal::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];
}

template <int wordCount>
union AlignedData {
  // Useful for declaring static constant data blobs as an array of bytes, but forcing those
  // bytes to be word-aligned.

  uint8_t bytes[wordCount * sizeof(word)];
  word words[wordCount];
};

struct StructSize {
  WordCount16 data;
  WireReferenceCount16 pointers;

  inline constexpr WordCount total() const { return data + pointers * WORDS_PER_REFERENCE; }

  StructSize() = default;
  inline constexpr StructSize(WordCount data, WireReferenceCount pointers)
      : data(data), pointers(pointers) {}
};

template <typename T>
class IsEnum {
  // Detects whether a primitive value is an enum.

  typedef char no;
  typedef long yes;

  static no test(int i);
  static yes test(...);

public:
  static constexpr bool value = sizeof(test(T())) == sizeof(yes);
};

// -------------------------------------------------------------------
// Masking of default values

template <typename T, bool isEnum = IsEnum<T>::value> struct MaskType { typedef T Type; };
template <typename T> struct MaskType<T, false> { typedef T Type; };
template <typename T> struct MaskType<T, true> { typedef uint16_t Type; };
template <> struct MaskType<float, false> { typedef uint32_t Type; };
template <> struct MaskType<double, false> { typedef uint64_t Type; };

template <typename T>
CAPNPROTO_ALWAYS_INLINE(
    typename MaskType<T>::Type mask(T value, typename MaskType<T>::Type mask));
template <typename T>
CAPNPROTO_ALWAYS_INLINE(
    T unmask(typename MaskType<T>::Type value, typename MaskType<T>::Type mask));

template <typename T>
inline typename MaskType<T>::Type mask(T value, typename MaskType<T>::Type mask) {
  return static_cast<typename MaskType<T>::Type>(value) ^ mask;
}

template <>
inline uint32_t mask<float>(float value, uint32_t mask) {
  uint32_t i;
  static_assert(sizeof(i) == sizeof(value), "float is not 32 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <>
inline uint64_t mask<double>(double value, uint64_t mask) {
  uint64_t i;
  static_assert(sizeof(i) == sizeof(value), "double is not 64 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <typename T>
inline T unmask(typename MaskType<T>::Type value, typename MaskType<T>::Type mask) {
  return static_cast<T>(value ^ mask);
}

template <>
inline float unmask<float>(uint32_t value, uint32_t mask) {
  value ^= mask;
  float result;
  static_assert(sizeof(result) == sizeof(value), "float is not 32 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}

template <>
inline double unmask<double>(uint64_t value, uint64_t mask) {
  value ^= mask;
  double result;
  static_assert(sizeof(result) == sizeof(value), "double is not 64 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}

// -------------------------------------------------------------------

template <typename T>
class WireValue {
  // Wraps a primitive value as it appears on the wire.  Namely, values are little-endian on the
  // wire, because little-endian is the most common endianness in modern CPUs.
  //
  // TODO:  On big-endian systems, inject byte-swapping here.  Most big-endian CPUs implement
  //   dedicated instructions for this, so use those rather than writing a bunch of shifts and
  //   masks.  Note that GCC has e.g. __builtin__bswap32() for this.
  //
  // Note:  In general, code that depends cares about byte ordering is bad.  See:
  //     http://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html
  //   Cap'n Proto is special because it is essentially doing compiler-like things, fussing over
  //   allocation and layout of memory, in order to squeeze out every last drop of performance.

public:
  WireValue() = default;
  CAPNPROTO_ALWAYS_INLINE(WireValue(T value)): value(value) {}

  CAPNPROTO_ALWAYS_INLINE(T get() const) { return value; }
  CAPNPROTO_ALWAYS_INLINE(void set(T newValue)) { value = newValue; }

private:
  T value;
};

class StructBuilder {
public:
  inline StructBuilder(): segment(nullptr), data(nullptr), references(nullptr) {}

  static StructBuilder initRoot(SegmentBuilder* segment, word* location, StructSize size);
  static StructBuilder getRoot(SegmentBuilder* segment, word* location, StructSize size);

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(ElementCount offset) const);
  // Gets the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(
      ElementCount offset, typename MaskType<T>::Type mask) const);
  // Like getDataField() but applies the given XOR mask to the data on load.  Used for reading
  // fields with non-zero default values.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataField(
      ElementCount offset, typename NoInfer<T>::Type value) const);
  // Sets the data field value at the given offset.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataField(
      ElementCount offset, typename NoInfer<T>::Type value, typename MaskType<T>::Type mask) const);
  // Like setDataField() but applies the given XOR mask before storing.  Used for writing fields
  // with non-zero default values.

  StructBuilder initStructField(WireReferenceCount refIndex, StructSize size) const;
  // Initializes the struct field at the given index in the reference segment.  If it is already
  // initialized, the previous value is discarded or overwritten.  The struct is initialized to
  // the type's default state (all-zero).  Use getStructField() if you want the struct to be
  // initialized as a copy of the field's default value (which may have non-null references).

  StructBuilder getStructField(WireReferenceCount refIndex, StructSize size,
                               const word* defaultValue) const;
  // Gets the struct field at the given index in the reference segment.  If the field is not already
  // initialized, it is initialized as a deep copy of the given default value (a trusted message),
  // or to the empty state if defaultValue is nullptr.

  CAPNPROTO_ALWAYS_INLINE(StructBuilder initInlineStructField(
      BitCount dataOffset, BitCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const);
  // Initialize an inlined struct field, given the position and size of the data and pointer
  // sections.

  CAPNPROTO_ALWAYS_INLINE(StructBuilder getInlineStructField(
      BitCount dataOffset, BitCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const);
  // Gets an inlined struct field, given the position and size of the data and pointer sections.

  ListBuilder initListField(WireReferenceCount refIndex, FieldSize elementSize,
                            ElementCount elementCount) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  All elements are initialized to zero.

  ListBuilder initStructListField(WireReferenceCount refIndex, ElementCount elementCount,
                                  StructSize size) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  Each element is initialized to its empty state.

  ListBuilder getListField(WireReferenceCount refIndex, const word* defaultValue) const;
  // Gets the already-allocated list field for the given reference index.  If the list is not
  // already allocated, it is allocated as a deep copy of the given default value (a trusted
  // message).  If the default value is null, an empty list is used.

  Text::Builder initTextField(WireReferenceCount refIndex, ByteCount size) const;
  // Initialize the text field to the given size in bytes (not including NUL terminator) and return
  // a Text::Builder which can be used to fill in the content.

  void setTextField(WireReferenceCount refIndex, Text::Reader value) const;
  // Set the text field to a copy of the given text.

  Text::Builder getTextField(WireReferenceCount refIndex,
                             const void* defaultValue, ByteCount defaultSize) const;
  // Get the text field.  If it is not initialized, initialize it to a copy of the given default.

  Data::Builder initDataField(WireReferenceCount refIndex, ByteCount size) const;
  void setDataField(WireReferenceCount refIndex, Data::Reader value) const;
  Data::Builder getDataField(WireReferenceCount refIndex,
                             const void* defaultValue, ByteCount defaultSize) const;
  // Same as *Text*, but for data blobs.

  StructReader asReader() const;
  // Gets a StructReader pointing at the same memory.

private:
  SegmentBuilder* segment;     // Memory segment in which the struct resides.
  void* data;                  // Pointer to the encoded data.
  WireReference* references;   // Pointer to the encoded references.

  BitCount8 bit0Offset;
  // A special hack:  When accessing a boolean with field number zero, pretend its offset is this
  // instead of the usual zero.  This is needed to support 1-bit inline structs.

  inline StructBuilder(SegmentBuilder* segment, void* data, WireReference* references,
                       BitCount8 bit0Offset)
      : segment(segment), data(data), references(references), bit0Offset(bit0Offset) {}

  friend class ListBuilder;
  friend struct WireHelpers;
};

class StructReader {
public:
  inline StructReader()
      : segment(nullptr), data(nullptr), references(nullptr), dataSize(0),
        referenceCount(0), bit0Offset(0 * BITS), nestingLimit(0) {}

  static StructReader readRootTrusted(const word* location);
  static StructReader readRoot(const word* location, SegmentReader* segment, int nestingLimit);
  static StructReader readEmpty();

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataField(ElementCount offset) const);
  // Get the data field value of the given type at the given offset.  The offset is measured in
  // multiples of the field size, determined by the type.  Returns zero if the offset is past the
  // end of the struct's data segment.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(
      T getDataField(ElementCount offset, typename MaskType<T>::Type mask) const);
  // Like getDataField(offset), but applies the given XOR mask to the result.  Used for reading
  // fields with non-zero default values.

  StructReader getStructField(WireReferenceCount refIndex, const word* defaultValue) const;
  // Get the struct field at the given index in the reference segment, or the default value if not
  // initialized.  defaultValue will be interpreted as a trusted message -- it must point at a
  // struct reference, which in turn points at the struct value.  The default value is allowed to
  // be null, in which case an empty struct is used.

  CAPNPROTO_ALWAYS_INLINE(StructReader getInlineStructField(
      BitCount dataOffset, BitCount inlineDataSize,
      WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const);
  // Gets an inlined struct field, given the position and size of the data and pointer sections.

  ListReader getListField(WireReferenceCount refIndex, FieldSize expectedElementSize,
                          const word* defaultValue) const;
  // Get the list field at the given index in the reference segment, or the default value if not
  // initialized.  The default value is allowed to be null, in which case an empty list is used.

  Text::Reader getTextField(WireReferenceCount refIndex,
                            const void* defaultValue, ByteCount defaultSize) const;
  // Gets the text field, or the given default value if not initialized.

  Data::Reader getDataField(WireReferenceCount refIndex,
                            const void* defaultValue, ByteCount defaultSize) const;
  // Gets the data field, or the given default value if not initialized.

private:
  SegmentReader* segment;  // Memory segment in which the struct resides.

  const void* data;
  const WireReference* references;

  BitCount32 dataSize;                 // Size of data segment.
  WireReferenceCount16 referenceCount;  // Size of the reference segment.

  BitCount8 bit0Offset;
  // A special hack:  When accessing a boolean with field number zero, pretend its offset is this
  // instead of the usual zero.  This is needed to allow a boolean list to be upgraded to a list
  // of structs, and to support 1-bit inline structs.

  int nestingLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.
  // TODO:  Limit to 8 bits for better alignment?

  inline StructReader(SegmentReader* segment, const void* data, const WireReference* references,
                      BitCount dataSize, WireReferenceCount referenceCount,
                      BitCount bit0Offset, int nestingLimit)
      : segment(segment), data(data), references(references),
        dataSize(dataSize), referenceCount(referenceCount), bit0Offset(bit0Offset),
        nestingLimit(nestingLimit) {}

  friend class ListReader;
  friend class StructBuilder;
  friend struct WireHelpers;
};

// -------------------------------------------------------------------

class ListBuilder {
public:
  inline ListBuilder(): segment(nullptr), ptr(nullptr), elementCount(0) {}

  inline ElementCount size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(ElementCount index) const);
  // Get the element of the given type at the given index.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(void setDataElement(
      ElementCount index, typename NoInfer<T>::Type value) const);
  // Set the element at the given index.

  StructBuilder getStructElement(
      ElementCount index, decltype(WORDS/ELEMENTS) elementSize, WordCount structDataSize) const;
  // Get the struct element at the given index.  elementSize is the size, in 64-bit words, of
  // each element.

  ListBuilder initListElement(
      WireReferenceCount index, FieldSize elementSize, ElementCount elementCount) const;
  // Create a new list element of the given size at the given index.  All elements are initialized
  // to zero.

  ListBuilder initStructListElement(WireReferenceCount index, ElementCount elementCount,
                                    StructSize size) const;
  // Allocates a new list of the given size for the field at the given index in the reference
  // segment, and return a pointer to it.  Each element is initialized to its empty state.

  ListBuilder getListElement(WireReferenceCount index) const;
  // Get the existing list element at the given index.  Returns an empty list if the element is
  // not initialized.

  Text::Builder initTextElement(WireReferenceCount index, ByteCount size) const;
  // Initialize the text element to the given size in bytes (not including NUL terminator) and
  // return a Text::Builder which can be used to fill in the content.

  void setTextElement(WireReferenceCount index, Text::Reader value) const;
  // Set the text element to a copy of the given text.

  Text::Builder getTextElement(WireReferenceCount index) const;
  // Get the text element.  If it is not initialized, returns an empty Text::Builder.

  Data::Builder initDataElement(WireReferenceCount index, ByteCount size) const;
  void setDataElement(WireReferenceCount index, Data::Reader value) const;
  Data::Builder getDataElement(WireReferenceCount index) const;

  ListReader asReader(FieldSize elementSize) const;
  // Get a ListReader pointing at the same memory.  Use this version only for non-struct lists.

  ListReader asReader(BitCount dataSize, WireReferenceCount referenceCount) const;
  // Get a ListReader pointing at the same memory.  Use this version only for struct lists.

private:
  SegmentBuilder* segment;  // Memory segment in which the list resides.
  word* ptr;  // Pointer to the beginning of the list.
  ElementCount elementCount;  // Number of elements in the list.

  inline ListBuilder(SegmentBuilder* segment, word* ptr, ElementCount size)
      : segment(segment), ptr(ptr), elementCount(size) {}

  friend class StructBuilder;
  friend struct WireHelpers;
};

class ListReader {
public:
  inline ListReader()
      : segment(nullptr), ptr(nullptr), elementCount(0),
        stepBits(0 * BITS / ELEMENTS), structDataSize(0),
        structReferenceCount(0), nestingLimit(0) {}

  inline ElementCount size();
  // The number of elements in the list.

  template <typename T>
  CAPNPROTO_ALWAYS_INLINE(T getDataElement(ElementCount index) const);
  // Get the element of the given type at the given index.

  StructReader getStructElement(ElementCount index) const;
  // Get the struct element at the given index.

  ListReader getListElement(WireReferenceCount index, FieldSize expectedElementSize) const;
  // Get the list element at the given index.

  Text::Reader getTextElement(WireReferenceCount index) const;
  // Get the text element.  If it is not initialized, returns an empty Text::Reader.

  Data::Reader getDataElement(WireReferenceCount index) const;
  // Get the data element.  If it is not initialized, returns an empty Data::Reader.

private:
  SegmentReader* segment;  // Memory segment in which the list resides.

  const void* ptr;
  // Pointer to the data.  If null, use defaultReferences.  (Never null for data lists.)
  // Must be aligned appropriately for the elements.

  ElementCount elementCount;  // Number of elements in the list.

  decltype(BITS / ELEMENTS) stepBits;
  // The distance between elements, in bits.  This is usually the element size, but can be larger
  // if the sender upgraded a data list to a struct list.  It will always be aligned properly for
  // the type.  Unsigned so that division by a constant power of 2 is efficient.

  BitCount structDataSize;
  WireReferenceCount structReferenceCount;
  // If the elements are structs, the properties of the struct.  The reference count is
  // only used to check for field presence; the data size is also used to compute the reference
  // pointer.

  int nestingLimit;
  // Limits the depth of message structures to guard against stack-overflow-based DoS attacks.
  // Once this reaches zero, further pointers will be pruned.

  inline ListReader(SegmentReader* segment, const void* ptr, ElementCount elementCount,
                    decltype(BITS / ELEMENTS) stepBits, int nestingLimit)
      : segment(segment), ptr(ptr), elementCount(elementCount), stepBits(stepBits),
        structDataSize(0), structReferenceCount(0),
        nestingLimit(nestingLimit) {}
  inline ListReader(SegmentReader* segment, const void* ptr, ElementCount elementCount,
                    decltype(BITS / ELEMENTS) stepBits, BitCount structDataSize,
                    WireReferenceCount structReferenceCount, int nestingLimit)
      : segment(segment), ptr(ptr), elementCount(elementCount), stepBits(stepBits),
        structDataSize(structDataSize), structReferenceCount(structReferenceCount),
        nestingLimit(nestingLimit) {}

  friend class StructReader;
  friend class ListBuilder;
  friend struct WireHelpers;
};

// =======================================================================================
// Internal implementation details...

template <typename T>
inline T StructBuilder::getDataField(ElementCount offset) const {
  return reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].get();
}

template <>
inline bool StructBuilder::getDataField<bool>(ElementCount offset) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);

  // This branch should always be optimized away when inlining.
  if (boffset == 0 * BITS) boffset = bit0Offset;

  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void StructBuilder::getDataField<Void>(ElementCount offset) const {
  return Void::VOID;
}

template <typename T>
inline T StructBuilder::getDataField(ElementCount offset, typename MaskType<T>::Type mask) const {
  return unmask<T>(getDataField<typename MaskType<T>::Type>(offset), mask);
}

template <typename T>
inline void StructBuilder::setDataField(
    ElementCount offset, typename NoInfer<T>::Type value) const {
  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);
}

template <>
inline void StructBuilder::setDataField<bool>(ElementCount offset, bool value) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);

  // This branch should always be optimized away when inlining.
  if (boffset == 0 * BITS) boffset = bit0Offset;

  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  uint bitnum = boffset % BITS_PER_BYTE / BITS;
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << bitnum))
                                 | (static_cast<uint8_t>(value) << bitnum);
}

template <>
inline void StructBuilder::setDataField<Void>(ElementCount offset, Void value) const {}

template <typename T>
inline void StructBuilder::setDataField(
    ElementCount offset, typename NoInfer<T>::Type value, typename MaskType<T>::Type m) const {
  setDataField<typename MaskType<T>::Type>(offset, mask<T>(value, m));
}

inline StructBuilder StructBuilder::initInlineStructField(
    BitCount dataOffset, BitCount inlineDataSize,
    WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const {
  // This branch should be optimized away.
  if (inlineDataSize == 1 * BITS) {
    setDataField<bool>(dataOffset / (1 * BITS / ELEMENTS), false);
  } else {
    memset(reinterpret_cast<byte*>(data) + dataOffset / BITS_PER_BYTE / BYTES,
           0, inlineDataSize / BITS_PER_BYTE / BYTES);
  }
  memset(reinterpret_cast<word*>(references) + refIndex * WORDS_PER_REFERENCE,
         0, inlineRefCount * WORDS_PER_REFERENCE * BYTES_PER_WORD / BYTES);
  return getInlineStructField(dataOffset, inlineDataSize, refIndex, inlineRefCount);
}

inline StructBuilder StructBuilder::getInlineStructField(
    BitCount dataOffset, BitCount inlineDataSize,
    WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const {
  return StructBuilder(
      segment, reinterpret_cast<byte*>(data) + dataOffset / BITS_PER_BYTE,
      // WireReference is incomplete here so we have to cast around...  Bah.
      reinterpret_cast<WireReference*>(
          reinterpret_cast<word*>(references) + refIndex * WORDS_PER_REFERENCE),
      dataOffset == 0 * BITS ? BitCount(bit0Offset) : dataOffset % BITS_PER_BYTE);
}

// -------------------------------------------------------------------

template <typename T>
T StructReader::getDataField(ElementCount offset) const {
  if (offset * capnproto::bitsPerElement<T>() < dataSize) {
    return reinterpret_cast<const WireValue<T>*>(data)[offset / ELEMENTS].get();
  } else {
    return static_cast<T>(0);
  }
}

template <>
inline bool StructReader::getDataField<bool>(ElementCount offset) const {
  BitCount boffset = offset * (1 * BITS / ELEMENTS);

  // This branch should always be optimized away when inlining.
  if (boffset == 0 * BITS) boffset = bit0Offset;

  if (boffset < dataSize) {
    const byte* b = reinterpret_cast<const byte*>(data) + boffset / BITS_PER_BYTE;
    return (*reinterpret_cast<const uint8_t*>(b) & (1 << (boffset % BITS_PER_BYTE / BITS))) != 0;
  } else {
    return false;
  }
}

template <>
inline Void StructReader::getDataField<Void>(ElementCount offset) const {
  return Void::VOID;
}

template <typename T>
T StructReader::getDataField(ElementCount offset, typename MaskType<T>::Type mask) const {
  return unmask<T>(getDataField<typename MaskType<T>::Type>(offset), mask);
}

inline StructReader StructReader::getInlineStructField(
    BitCount dataOffset, BitCount inlineDataSize,
    WireReferenceCount refIndex, WireReferenceCount inlineRefCount) const {
  return StructReader(
      segment, reinterpret_cast<const byte*>(data) + dataOffset / BITS_PER_BYTE,
      // WireReference is incomplete here so we have to cast around...  Bah.
      reinterpret_cast<const WireReference*>(
          reinterpret_cast<const word*>(references) + refIndex * WORDS_PER_REFERENCE),
      dataSize, inlineRefCount,
      dataOffset == 0 * BITS ? BitCount(bit0Offset) : dataOffset % BITS_PER_BYTE,
      nestingLimit);
}

// -------------------------------------------------------------------

inline ElementCount ListBuilder::size() { return elementCount; }

template <typename T>
inline T ListBuilder::getDataElement(ElementCount index) const {
  return reinterpret_cast<WireValue<T>*>(ptr)[index / ELEMENTS].get();
}

template <>
inline bool ListBuilder::getDataElement<bool>(ElementCount index) const {
  BitCount bindex = index * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(ptr) + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void ListBuilder::getDataElement<Void>(ElementCount index) const {
  return Void::VOID;
}

template <typename T>
inline void ListBuilder::setDataElement(ElementCount index, typename NoInfer<T>::Type value) const {
  reinterpret_cast<WireValue<T>*>(ptr)[index / ELEMENTS].set(value);
}

template <>
inline void ListBuilder::setDataElement<bool>(ElementCount index, bool value) const {
  BitCount bindex = index * (1 * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(ptr) + bindex / BITS_PER_BYTE;
  uint bitnum = bindex % BITS_PER_BYTE / BITS;
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << bitnum))
                                 | (static_cast<uint8_t>(value) << bitnum);
}

template <>
inline void ListBuilder::setDataElement<Void>(ElementCount index, Void value) const {}

// -------------------------------------------------------------------

inline ElementCount ListReader::size() { return elementCount; }

template <typename T>
inline T ListReader::getDataElement(ElementCount index) const {
  return *reinterpret_cast<const T*>(
      reinterpret_cast<const byte*>(ptr) + index * stepBits / BITS_PER_BYTE);
}

template <>
inline bool ListReader::getDataElement<bool>(ElementCount index) const {
  BitCount bindex = index * stepBits;
  const byte* b = reinterpret_cast<const byte*>(ptr) + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<const uint8_t*>(b) & (1 << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <>
inline Void ListReader::getDataElement<Void>(ElementCount index) const {
  return Void::VOID;
}

}  // namespace internal
}  // namespace capnproto

#endif  // CAPNPROTO_LAYOUT_H_
